<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lessons learnt updating a library to std::future</title>
    <meta name="description" content="Updating a multipart-async library to use futures" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script defer data-domain="cetra3.github.io" src="https://track.divedb.net/js/plausible.js"></script>
    <style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}hr{box-sizing:content-box;height:0;overflow:visible;}a{background-color:rgba(0,0,0,0);-webkit-text-decoration-skip:objects;}a:active,a:hover{outline-width:0}address{font-style:normal}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:"SF Mono","Segoe UI Mono","Roboto Mono",Menlo,Courier,monospace;font-size:1em;}dfn{font-style:italic}small{font-size:80%;font-weight:400;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;margin:0;}button,input{overflow:visible}button,select{text-transform:none}button,html [type=button],[type=reset],[type=submit]{-webkit-appearance:button;}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}fieldset{border:0;margin:0;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{display:inline-block;vertical-align:baseline;}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0;}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px;}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details,menu{display:block}summary{display:list-item;outline:none}canvas{display:inline-block}template{display:none}[hidden]{display:none}*,*::before,*::after{box-sizing:inherit}html{box-sizing:border-box;font-size:20px;line-height:1.5;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{background:#303742;color:#fff;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;font-size:.8rem;overflow-x:hidden;text-rendering:optimizeLegibility}a{color:#73c6ec;outline:none;text-decoration:none}a:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}a:focus,a:hover,a:active,a.active{color:#46b4e6;text-decoration:underline}a:visited{color:#a0d8f2}h1,h2,h3,h4,h5,h6{color:inherit;font-weight:700;line-height:1.2;margin-bottom:.5rem;margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{font-weight:700}h1,.h1{font-size:2rem}h2,.h2{font-size:1.6rem}h3,.h3{font-size:1.4rem}h4,.h4{font-size:1.2rem}h5,.h5{font-size:1rem}h6,.h6{font-size:.8rem}p{margin:0 0 1.2rem}a,ins,u{text-decoration-skip:ink edges}abbr[title]{border-bottom:.05rem dotted;cursor:help;text-decoration:none}kbd{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#303742;color:#fff;font-size:.7rem}mark{background:#ffe9b3;color:#fff;border-bottom:.05rem solid #ffd367;border-radius:.1rem;padding:.05rem .1rem 0}blockquote{border-left:.1rem solid #dadee4;margin-left:0;padding:.4rem .8rem}blockquote p:last-child{margin-bottom:0}ul,ol{margin:.8rem 0 .8rem .8rem;padding:0}ul ul,ul ol,ol ul,ol ol{margin:.8rem 0 .8rem .8rem}ul li,ol li{margin-top:.4rem}ul{list-style:disc inside}ul ul{list-style-type:circle}ol{list-style:decimal inside}ol ol{list-style-type:lower-alpha}dl dt{font-weight:bold}dl dd{margin:.4rem 0 .8rem 0}.btn{appearance:none;background:#fff;border:.05rem solid #73c6ec;border-radius:.1rem;color:#73c6ec;cursor:pointer;display:inline-block;font-size:.8rem;height:2.5rem;line-height:1.2rem;outline:none;padding:.6rem .4rem;text-align:center;text-decoration:none;transition:background .2s,border .2s,box-shadow .2s,color .2s;user-select:none;vertical-align:middle;white-space:nowrap}.btn:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}.btn:focus,.btn:hover{background:#fff;border-color:#66c1ea;text-decoration:none}.btn:active,.btn.active{background:#66c1ea;border-color:#4fb7e7;color:#fff;text-decoration:none}.btn:active.loading::after,.btn.active.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn[disabled],.btn:disabled,.btn.disabled{cursor:default;opacity:.5;pointer-events:none}.btn.btn-primary{background:#73c6ec;border-color:#66c1ea;color:#fff}.btn.btn-primary:focus,.btn.btn-primary:hover{background:#5dbde9;border-color:#4fb7e7;color:#fff}.btn.btn-primary:active,.btn.btn-primary.active{background:#54b9e8;border-color:#46b4e6;color:#fff}.btn.btn-primary.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-success{background:#32b643;border-color:#2faa3f;color:#fff}.btn.btn-success:focus{box-shadow:0 0 0 .1rem rgba(50,182,67,.2)}.btn.btn-success:focus,.btn.btn-success:hover{background:#30ae40;border-color:#2da23c;color:#fff}.btn.btn-success:active,.btn.btn-success.active{background:#2a9a39;border-color:#278e34;color:#fff}.btn.btn-success.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-error{background:#e85600;border-color:#d95000;color:#fff}.btn.btn-error:focus{box-shadow:0 0 0 .1rem rgba(232,86,0,.2)}.btn.btn-error:focus,.btn.btn-error:hover{background:#de5200;border-color:#cf4d00;color:#fff}.btn.btn-error:active,.btn.btn-error.active{background:#c44900;border-color:#b54300;color:#fff}.btn.btn-error.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-link{background:rgba(0,0,0,0);border-color:rgba(0,0,0,0);color:#73c6ec}.btn.btn-link:focus,.btn.btn-link:hover,.btn.btn-link:active,.btn.btn-link.active{color:#46b4e6}.btn.btn-sm{font-size:.7rem;height:1.4rem;padding:.05rem .3rem}.btn.btn-lg{font-size:.9rem;height:2rem;padding:.35rem .6rem}.btn.btn-block{display:block;width:100%}.btn.btn-action{width:2.5rem;padding-left:0;padding-right:0}.btn.btn-action.btn-sm{width:1.4rem}.btn.btn-action.btn-lg{width:2rem}.btn.btn-clear{background:rgba(0,0,0,0);border:0;color:currentColor;height:1rem;line-height:.8rem;margin-left:.2rem;margin-right:-2px;opacity:1;padding:.1rem;text-decoration:none;width:1rem}.btn.btn-clear:focus,.btn.btn-clear:hover{background:rgba(48,55,66,.5);opacity:.95}.btn.btn-clear::before{content:"âœ•"}.btn-group{display:inline-flex;flex-wrap:wrap}.btn-group .btn{flex:1 0 auto}.btn-group .btn:first-child:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group .btn:not(:first-child):not(:last-child){border-radius:0;margin-left:-.05rem}.btn-group .btn:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-.05rem}.btn-group .btn:focus,.btn-group .btn:hover,.btn-group .btn:active,.btn-group .btn.active{z-index:1}.btn-group.btn-group-block{display:flex}.btn-group.btn-group-block .btn{flex:1 0 0}.label{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#39414e;color:#e6e6e6;display:inline-block}.label.label-rounded{border-radius:5rem;padding-left:.4rem;padding-right:.4rem}.label.label-primary{background:#0b3e55;color:#fff}.label.label-secondary{background:#fff;color:#73c6ec}.label.label-success{background:#32b643;color:#fff}.label.label-warning{background:#ffb700;color:#fff}.label.label-error{background:#e85600;color:#fff}p code{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#0f4e6b;color:#fff;font-size:85%}.code{border-radius:.1rem;color:#fff;position:relative}.code::before{color:#bcc3ce;content:attr(data-lang);font-size:.7rem;position:absolute;right:.4rem;top:.1rem}.code code{background:#303742;color:inherit;display:block;line-height:1.5;overflow-x:auto;padding:1rem;width:100%}.container{margin-left:auto;margin-right:auto;padding-left:.4rem;padding-right:.4rem;width:100%}.container.grid-xl{max-width:1296px}.container.grid-lg{max-width:976px}.container.grid-md{max-width:856px}.container.grid-sm{max-width:616px}.container.grid-xs{max-width:496px}.show-xs,.show-sm,.show-md,.show-lg,.show-xl{display:none !important}.columns{display:flex;flex-wrap:wrap;margin-left:-.4rem;margin-right:-.4rem}.columns.col-gapless{margin-left:0;margin-right:0}.columns.col-gapless>.column{padding-left:0;padding-right:0}.columns.col-oneline{flex-wrap:nowrap;overflow-x:auto}.column{flex:1;max-width:100%;padding-left:.4rem;padding-right:.4rem}.column.col-12,.column.col-11,.column.col-10,.column.col-9,.column.col-8,.column.col-7,.column.col-6,.column.col-5,.column.col-4,.column.col-3,.column.col-2,.column.col-1{flex:none}.col-12{width:100%}.col-11{width:91.66666667%}.col-10{width:83.33333333%}.col-9{width:75%}.col-8{width:66.66666667%}.col-7{width:58.33333333%}.col-6{width:50%}.col-5{width:41.66666667%}.col-4{width:33.33333333%}.col-3{width:25%}.col-2{width:16.66666667%}.col-1{width:8.33333333%}.col-auto{flex:0 0 auto;max-width:none;width:auto}.col-mx-auto{margin-left:auto;margin-right:auto}.col-ml-auto{margin-left:auto}.col-mr-auto{margin-right:auto}@media (max-width: 1280px){.col-xl-12,.col-xl-11,.col-xl-10,.col-xl-9,.col-xl-8,.col-xl-7,.col-xl-6,.col-xl-5,.col-xl-4,.col-xl-3,.col-xl-2,.col-xl-1{flex:none}.col-xl-12{width:100%}.col-xl-11{width:91.66666667%}.col-xl-10{width:83.33333333%}.col-xl-9{width:75%}.col-xl-8{width:66.66666667%}.col-xl-7{width:58.33333333%}.col-xl-6{width:50%}.col-xl-5{width:41.66666667%}.col-xl-4{width:33.33333333%}.col-xl-3{width:25%}.col-xl-2{width:16.66666667%}.col-xl-1{width:8.33333333%}.hide-xl{display:none !important}.show-xl{display:block !important}}@media (max-width: 960px){.col-lg-12,.col-lg-11,.col-lg-10,.col-lg-9,.col-lg-8,.col-lg-7,.col-lg-6,.col-lg-5,.col-lg-4,.col-lg-3,.col-lg-2,.col-lg-1{flex:none}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.hide-lg{display:none !important}.show-lg{display:block !important}}@media (max-width: 840px){.col-md-12,.col-md-11,.col-md-10,.col-md-9,.col-md-8,.col-md-7,.col-md-6,.col-md-5,.col-md-4,.col-md-3,.col-md-2,.col-md-1{flex:none}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.hide-md{display:none !important}.show-md{display:block !important}}@media (max-width: 600px){.col-sm-12,.col-sm-11,.col-sm-10,.col-sm-9,.col-sm-8,.col-sm-7,.col-sm-6,.col-sm-5,.col-sm-4,.col-sm-3,.col-sm-2,.col-sm-1{flex:none}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.hide-sm{display:none !important}.show-sm{display:block !important}}@media (max-width: 480px){.col-xs-12,.col-xs-11,.col-xs-10,.col-xs-9,.col-xs-8,.col-xs-7,.col-xs-6,.col-xs-5,.col-xs-4,.col-xs-3,.col-xs-2,.col-xs-1{flex:none}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.hide-xs{display:none !important}.show-xs{display:block !important}}.navbar{align-items:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin-left:auto;margin-right:auto;max-width:960px}.navbar .navbar-section{align-items:center;display:flex;flex:1 0 0}.navbar .navbar-section:not(:first-child):last-child{justify-content:flex-end}.navbar .navbar-center{align-items:center;display:flex;flex:0 0 auto}.navbar .navbar-brand{font-size:.9rem;text-decoration:none}pre{padding:.5rem .5rem;border-radius:.3rem;overflow-y:auto}.post header{border-radius:.3rem;padding:.5rem;margin-bottom:.5rem}.post header h1{margin-bottom:0}.post section{padding:.5rem;background-color:#2a3039;border-radius:.3rem}.post img{width:100%}.post .utterances{max-width:none !important}.card{margin-bottom:.5rem}.main-header{margin-bottom:.5rem;background-color:#272d36;box-shadow:0 20rem 20rem 20rem rgba(115,198,236,.2)}.card{background:#2a3039;border-radius:.3rem;display:flex;flex-direction:column}.card .card-header,.card .card-body,.card .card-footer{padding:.8rem;padding-bottom:0}.card .card-header:last-child,.card .card-body:last-child,.card .card-footer:last-child{padding-bottom:.8rem}.card .card-body{flex:1 1 auto}.card .card-image{padding-top:.8rem}.card .card-image:first-child{padding-top:0}.card .card-image:first-child img{border-top-left-radius:.1rem;border-top-right-radius:.1rem}.card .card-image:last-child img{border-bottom-left-radius:.1rem;border-bottom-right-radius:.1rem}</style>
</head>

<body>
    <header class="main-header">
        <div class="navbar">
        <section class="navbar-section">
            <img src="/favicon.svg" width="30" height="30"/>
            <a href="/" class="btn btn-link">Home</a>
            <a href="/blog/" class="btn btn-link">Blogs</a>
            <a href="/rss.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
        </div>
    </header>
    <div class="container grid-lg">
        
<article class="post">
  <header>
  <h1>Lessons learnt updating a library to std::future </h1>
  <em>Updating a multipart-async library to use futures</em>
  <br />
  
  <small class="label label-primary">rust</small> <small class="label label-primary">mpart-async</small> <small class="label">2020-01-22</small>
  
  </header>
  <section>
    <p>With the new <code>std::future</code> way of doing things and <a href="https://tokio.rs">tokio</a> slowly reaching maturation, it's time to look at updating the libraries out there that are using <em>the old ways</em>.  For one of my libraries, <a href="https://crates.io/crates/tmq">tmq</a>, a Tokio ZeroMQ library, there is some <a href="https://github.com/cetra3/tmq/pull/5">awesome work already done</a> to get this updated.</p>
<p>But, I thought it pertinent to at least get my feet in the water to see how hard it would be, from a library maintainer perspective, to update to <code>std::future</code>.  For this effort, I chose my small library: <a href="https://crates.io/crates/mpart-async">mpart-async</a>.   You can see the changes I have made by comparing the <a href="https://github.com/cetra3/mpart-async/compare/0.2.1...0.3.0">versions</a> here.  This blog is a small collection of notes &amp; gotches I found when porting code across.</p>
<p><code>mpart-async</code> is a <em>mostly</em> agnostic library for client side <code>multipart/form-data</code> requests.  There are existing libraries out there, like <a href="https://crates.io/crates/multipart">multipart</a>, but I found the API a little unwieldy for my taste (That: and async support is <a href="https://github.com/abonander/multipart-async">still in alpha</a> according to the readme). I wanted something that worked, and was simple, but didn't offer an opinion on the web client. I use both the <a href="https://github.com/actix/actix-web/tree/master/awc">actix client</a> &amp;  <a href="https://crates.io/crates/hyper">hyper</a> to make multipart requests depending on the project.</p>
<p>The challenge is that with multipart requests you mostly have fields &amp; binary files.  For binary files, you can appreciate, should not be buffered entirely in memory, but streamed out as the bytes become available.  So <code>mpart-async</code> works with multiple internal streams of files and also provides a <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs">convenience wrapper</a> (if using tokio) for sending files given a path.</p>
<h2 id="a-new-example">A New Example</h2>
<p>All these changes to support <code>async fn</code> and is it actually easier to consume/use async libraries?</p>
<p>Given the <a href="https://crates.io/crates/hyper">hyper</a> example, I would say yes.</p>
<p>Compare the <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/examples/hyper.rs">new example</a>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">tokio</span><span>::</span><span style="color:#ffd580;">main</span><span>]
</span><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span>() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;(), Error&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Setup a mock server to accept connections.
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//....
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> client </span><span style="color:#f29e74;">= </span><span>Client</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let mut</span><span> mpart </span><span style="color:#f29e74;">= </span><span>MultipartRequest</span><span style="color:#f29e74;">::</span><span>default()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_field</span><span>(</span><span style="color:#bae67e;">&quot;foo&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;bar&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>    mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_file</span><span>(</span><span style="color:#bae67e;">&quot;test&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> request </span><span style="color:#f29e74;">= </span><span>Request</span><span style="color:#f29e74;">::</span><span>post(</span><span style="color:#bae67e;">&quot;http://localhost:3000&quot;</span><span>)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">header</span><span>(
</span><span>            </span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">,
</span><span>            </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;multipart/form-data; boundary=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">get_boundary</span><span>())</span><span style="color:#ccc9c2cc;">,
</span><span>        )
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">body</span><span>(Body</span><span style="color:#f29e74;">::</span><span>wrap_stream(mpart))</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    client</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request</span><span>(request)</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p>With the <a href="https://github.com/cetra3/mpart-async/blob/c928f015fa31cd57533d4ba43551a9a96b61b0a2/examples/hyper.rs">older one</a>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span>() {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// current_thread::Runtime can&#39;t be used because of the blocking file operations
</span><span>    </span><span style="color:#ffa759;">let mut</span><span> rt </span><span style="color:#f29e74;">= </span><span>Runtime</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;new rt&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Setup a mock server to accept connections.
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//....
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Open `Cargo.toml` file and create a request
</span><span>    </span><span style="color:#ffa759;">let</span><span> request </span><span style="color:#f29e74;">= </span><span>File</span><span style="color:#f29e74;">::</span><span>open(</span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span>)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> e))
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|</span><span style="color:#ffcc66;">file</span><span>| {
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// A Stream of BytesMut decoded from an AsyncRead
</span><span>            </span><span style="color:#ffa759;">let</span><span> framed </span><span style="color:#f29e74;">= </span><span>FramedRead</span><span style="color:#f29e74;">::</span><span>new(file</span><span style="color:#ccc9c2cc;">, </span><span>BytesCodec</span><span style="color:#f29e74;">::</span><span>new())</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>            </span><span style="color:#ffa759;">let mut</span><span> mpart </span><span style="color:#f29e74;">= </span><span>MultipartRequest</span><span style="color:#f29e74;">::</span><span>default()</span><span style="color:#ccc9c2cc;">;
</span><span>            mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_field</span><span>(</span><span style="color:#bae67e;">&quot;foo&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;bar&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>            mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_stream</span><span>(
</span><span>                </span><span style="color:#bae67e;">&quot;foofile&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>                </span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>                </span><span style="color:#bae67e;">&quot;application/toml&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>                framed</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">b</span><span>| b</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">freeze</span><span>())</span><span style="color:#ccc9c2cc;">,
</span><span>            )</span><span style="color:#ccc9c2cc;">;
</span><span>            Request</span><span style="color:#f29e74;">::</span><span>post(</span><span style="color:#bae67e;">&quot;http://localhost:3000&quot;</span><span>)
</span><span>                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">header</span><span>(
</span><span>                    </span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">,
</span><span>                    </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;multipart/form-data; boundary=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">get_boundary</span><span>())</span><span style="color:#ccc9c2cc;">,
</span><span>                )</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">body</span><span>(Body</span><span style="color:#f29e74;">::</span><span>wrap_stream(mpart))
</span><span>                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_future</span><span>()
</span><span>                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> e))
</span><span>        })</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Send request
</span><span>    </span><span style="color:#ffa759;">let</span><span> task </span><span style="color:#f29e74;">=</span><span> request</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|</span><span style="color:#ffcc66;">request</span><span>| {
</span><span>        </span><span style="color:#ffa759;">let</span><span> client </span><span style="color:#f29e74;">= </span><span>hyper</span><span style="color:#f29e74;">::</span><span>Client</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>        client
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request</span><span>(request)
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> e))
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|</span><span style="color:#ffcc66;">response</span><span>| {
</span><span>                response
</span><span>                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_body</span><span>()
</span><span>                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span>()
</span><span>                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| </span><span style="color:#f28779;">format!</span><span>(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> e))
</span><span>                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|</span><span style="color:#ffcc66;">body</span><span>| {
</span><span>                        </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(data) </span><span style="color:#f29e74;">= </span><span style="color:#ffa759;">str</span><span style="color:#f29e74;">::</span><span>from_utf8(</span><span style="color:#f29e74;">&amp;</span><span>body) {
</span><span>                            </span><span style="color:#f28779;">println!</span><span>(</span><span style="color:#bae67e;">&quot;Response: </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span> data)</span><span style="color:#ccc9c2cc;">;
</span><span>                        }
</span><span>                        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(())
</span><span>                    })
</span><span>            })
</span><span>    })</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    rt</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">block_on</span><span>(task)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;request failed&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>While there are still a few warts (such as having to manually add the boundary header), I find the code a lot more readable and easy to follow, rather than your standard combinator paths.</p>
<h2 id="no-more-error-associated-type">No more <code>Error</code> Associated Type</h2>
<p>The most drastic change to the <code>Stream</code> trait is that there is no longer an <code>Error</code> associated type.  The old <code>Stream</code>/<code>Future</code> traits had both <code>Item</code> and <code>Error</code>, as it assumed that streams were always going to be fallible.  The new traits do away with the <code>Error</code> associated type.  Instead, if you want your <code>Stream</code> to possibly be an error then you need to return a <code>Result</code> as your <code>Item</code> type.</p>
<p>For the <code>Stream</code> trait, the method you implement has changed to <code>poll_next</code> and uses the <code>std::task::Poll</code> enum as a return type.</p>
<p>The <code>Poll</code> enum did feel a little inside out when I started using it, but makes sense in terms of there being no <code>Error</code> type.  You don't return a <code>Result&lt;Async&lt;Option&gt;, _&gt;...</code> you instead return a <code>Poll&lt;Option&lt;Result&lt;_,_&gt;&gt;&gt;</code>.</p>
<p>Generally, this means if you wrote this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">return </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(Async</span><span style="color:#f29e74;">::</span><span>Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(bytes)))
</span></code></pre>
<p>You instead will return:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">return </span><span>Poll</span><span style="color:#f29e74;">::</span><span>Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(bytes)))
</span></code></pre>
<h2 id="streamext-traits-and-friends"><code>StreamExt</code> traits and friends</h2>
<p>As a consequence of no <code>Error</code> associated type, and an example of different ergonomics, if you are dealing with <code>Result</code> items, you may want to use the <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html">TryStreamExt</a> trait instead of <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.StreamExt.html">StreamExt</a>.  They are basically the same trait but one deals with <code>Result</code> a bit more nicely.  I'm not sure whether a simpler solution will be possible with higher kinded types in the future, but for now it is a tiny bit more complex than futures 0.1.</p>
<p>Interestingly, the <a href="https://docs.rs/futures/0.3.1/futures/stream/index.html">index page</a> for stream docs doesn't currently mention that the <code>TryStreamExt</code> trait exists &amp; I only found out about it by asking questions in the <a href="https://discord.gg/tokio">discord chat</a>.</p>
<p>But wait, there is also <a href="https://docs.rs/tokio/0.2.10/tokio/stream/trait.StreamExt.html">StreamExt</a> from tokio  which is subtly different, but does as of <code>0.2.10</code> allow you to run <code>collect()</code> on <code>Result&lt;Bytes, _&gt;</code> item streams.</p>
<p>When would you use either <code>StreamExt</code>?  I would say that if you want to be more general, you should probably use the <code>futures</code>  implementation.  Bearing in mind you can't run <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html#method.try_collect"><code>try_collect()</code></a> on <code>Result&lt;Bytes, _&gt;</code> at the moment due to an <a href="https://github.com/tokio-rs/bytes/issues/324">outstanding issue</a> with the bytes crate.  Why does this matter? Well, <a href="https://hyper.rs/">hyper</a> passes around streams of <code>Result&lt;Bytes, _&gt;</code> when you are streaming a body in &amp; out of a request.  Working with this particular stream signature is a bit clunky still, but I'm sure that this will be resolved in due course.</p>
<p>So we have:</p>
<ul>
<li><code>StreamExt</code> from <code>futures</code> that works on <code>Stream</code> that aren't <code>Result</code></li>
<li><code>TryStreamExt</code> from <code>futures</code> that works on <code>Stream</code> that are <code>Result</code> but doesn't work well with <code>Result&lt;Bytes,_&gt;</code> when trying to <code>try_collect()</code></li>
<li><code>StreamExt</code> from <code>tokio</code> that works with <code>Result&lt;Bytes,_&gt;</code> and allows you to <code>collect()</code> to get the output but now means you have a dependency on <code>tokio</code></li>
</ul>
<p>This might end up confusing more than just me, and I do hope that it's simplified in the future.</p>
<p>Luckily in the core of the API I don't need to use them, only for tests &amp; filestream, which means I'm quite happy to depend on the <code>tokio</code> implementation.</p>
<h2 id="wrapping-inner-streams-in-pin">Wrapping inner streams in <code>Pin</code></h2>
<p>I got tripped up on this for a while, and needed to again ask in chat for the answer here. If you have an inner stream and you want to call <code>poll_next</code> on it, you need to wrap it in a <code>Pin</code>, otherwise the <code>Stream</code> trait does not stick and you will get some gnarly error message with some weird suggestions:</p>
<p>The my original shot at the code was:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>stream</span><span style="color:#f29e74;">.</span><span>stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span>(cx)
</span></code></pre>
<p>But it needs to be:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>Pin</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> stream</span><span style="color:#f29e74;">.</span><span>stream)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span>(cx)
</span></code></pre>
<p>The compiler error message is not too helpful here, and insists I restrict <code>S</code> by <code>Stream</code>, even though it is already restricted by <code>Stream</code>.</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>error[E0599]: no method named `poll_next` found for type `S` in the current scope
</span><span>   --&gt; src/lib.rs:282:41
</span><span>    |
</span><span>282 |                     match stream.stream.poll_next(cx) {
</span><span>    |                                         ^^^^^^^^^ method not found in `S`
</span><span>    |
</span><span>    = help: items from traits can only be used if the type parameter is bounded by the trait
</span><span>help: the following trait defines an item `poll_next`, perhaps you need to restrict type parameter `S` with it:
</span><span>    |
</span><span>254 | impl&lt;E, S: futures::Stream + Stream&gt; Stream for MultipartRequest&lt;S&gt;
</span><span>    |         ^^^^^^^^^^^^^^^^^^^^
</span></code></pre>
<p>You need to make sure that your inner stream implements <code>Unpin</code> as well to go down this path:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl</span><span>&lt;E, S&gt; Stream </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">MultipartRequest</span><span>&lt;S&gt;
</span><span style="color:#ffa759;">where
</span><span>    S</span><span style="color:#ccc9c2cc;">: </span><span>Stream&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;Bytes, E&gt;&gt; + Unpin,
</span></code></pre>
<h2 id="storing-the-results-from-an-async-fn-in-a-struct">Storing the results from an <code>async fn</code> in a struct</h2>
<p>Some of the methods in tokio are returns from an <code>async fn</code> , like the <a href="https://docs.rs/tokio/0.2.10/tokio/fs/struct.File.html#method.open">File::open</a> method, which I use for <code>FileStream</code>.  I found the answer on <a href="https://stackoverflow.com/questions/58354633/cannot-use-impl-future-to-store-async-function-in-a-vector">stack overflow</a> as to how to do this with <code>std::future</code>, since <code>async fn</code> returns an opaque type.</p>
<p>For the older version, the OpenFuture was a concrete type:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">FileStream </span><span>{
</span><span>    inner</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
</span><span>    file</span><span style="color:#ccc9c2cc;">: </span><span>OpenFuture&lt;PathBuf&gt;,
</span><span>}
</span></code></pre>
<p>The newer version is a return from an <code>async fn</code> and is opaque, so we wrap it using <code>Box::pin</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">FileStream </span><span>{
</span><span>    inner</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
</span><span>    file</span><span style="color:#ccc9c2cc;">: </span><span>Pin&lt;</span><span style="font-style:italic;color:#5ccfe6;">Box</span><span>&lt;dyn Future&lt;Output = </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;File, Error&gt;&gt; </span><span style="color:#f29e74;">+ </span><span style="font-style:italic;color:#5ccfe6;">Send </span><span style="color:#f29e74;">+ </span><span style="font-style:italic;color:#5ccfe6;">Sync</span><span>&gt;&gt;,
</span><span>}
</span></code></pre>
<p>You can then instantiate this with:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5ccfe6;">Box</span><span style="color:#f29e74;">::</span><span>pin(File</span><span style="color:#f29e74;">::</span><span>open(file</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span>()))
</span></code></pre>
<p>Then it's easy to call passing on the context from an existing <code>poll()</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>file</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">as_mut</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll</span><span>(cx)
</span></code></pre>
<h2 id="notifying-a-task">Notifying a task</h2>
<p><code>FileStream</code> has two stages.  One is the future to open the file. The second is streaming out the bytes of the file.  When the future resolves to open the file, I want to notify the context that it should be polled again to start streaming.</p>
<p>The old way of doing this was <code>task::current().notify()</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>inner </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(FramedRead</span><span style="color:#f29e74;">::</span><span>new(file</span><span style="color:#ccc9c2cc;">, </span><span>BytesCodec</span><span style="color:#f29e74;">::</span><span>new()))</span><span style="color:#ccc9c2cc;">;
</span><span>task</span><span style="color:#f29e74;">::</span><span>current()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">notify</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>The new way appears to be using  <code>cx.waker().wake_by_ref()</code> where <code>cx</code> is the context received from the poll:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>inner </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(FramedRead</span><span style="color:#f29e74;">::</span><span>new(file</span><span style="color:#ccc9c2cc;">, </span><span>BytesCodec</span><span style="color:#f29e74;">::</span><span>new()))</span><span style="color:#ccc9c2cc;">;
</span><span>cx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">waker</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wake_by_ref</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>I say appears because the test written works without <code>wake_by_ref()</code> being called.  Requires a bit more investigation here I think to know exactly what's going on.  My <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs#L56">simple test example</a> works either way, strangely.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is not too onerous to convert to <code>std::future</code> for an existing library.  I would assume the leap from the old <code>tokio-core</code> would be harder, as the changes <em>feel</em> mostly cosmetic here.</p>
<p>The omission of the <code>Error</code> associated type to me actually makes things less ergonomic and things a little more fragmented (as evidenced by 3 <code>*StreamExt</code> traits..).  I was an advocate of this initially, but there probably needs to be a bit more work in making this nicer.</p>
<p>There are still a lot of libraries out there that will be required to be updated, a lot of old blogs that are no longer relevant, and a lot of exploration that needs to be done to see how the async ecosystem falls out.  But considering the friction of updating is quite small, I am quitely optimistic!</p>

  </section>
</article>


    </div>
</body>

</html>