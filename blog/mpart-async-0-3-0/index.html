<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Lessons learnt updating a library to std::future - Cetra&#x27;s Thoughts </title>
    <link href="/spectre.css" rel="stylesheet">
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
</head>

<body>
    <header class="navbar">
        <section class="navbar-section">
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
    </header>
    <div class="container grid-lg">
        
<div class="post">
  <h1>Lessons learnt updating a library to std::future </h1>
  
  <p> <small class="label label-primary">rust</small> <small class="label label-primary">mpart-async</small> <small class="label">2020-01-22</small></p>
  
  <p>With the new <code>std::future</code> way of doing things and <a href="https://tokio.rs">tokio</a> slowly reaching maturation, it's time to look at updating the libraries out there that are using <em>the old ways</em>.  For one of my libraries, <a href="https://crates.io/crates/tmq">tmq</a>, a Tokio ZeroMQ library, there is some <a href="https://github.com/cetra3/tmq/pull/5">awesome work already done</a> to get this updated.</p>
<p>But, I thought it pertinent to at least get my feet in the water to see how hard it would be, from a library maintainer perspective, to update to <code>std::future</code>.  For this effort, I chose my small library: <a href="https://crates.io/crates/mpart-async">mpart-async</a>.   You can see the changes I have made by comparing the <a href="https://github.com/cetra3/mpart-async/compare/0.2.1...0.3.0">versions</a> here.  This blog is a small collection of notes &amp; gotches I found when porting code across.</p>
<p><code>mpart-async</code> is a <em>mostly</em> agnostic library for client side <code>multipart/form-data</code> requests.  There are existing libraries out there, like <a href="https://crates.io/crates/multipart">multipart</a>, but I found the API a little unwieldy for my taste (That: and async support is <a href="https://github.com/abonander/multipart-async">still in alpha</a> according to the readme). I wanted something that worked, and was simple, but didn't offer an opinion on the web client. I use both the <a href="https://github.com/actix/actix-web/tree/master/awc">actix client</a> &amp;  <a href="https://crates.io/crates/hyper">hyper</a> to make multipart requests depending on the project.</p>
<p>The challenge is that with multipart requests you mostly have fields &amp; binary files.  For binary files, you can appreciate, should not be buffered entirely in memory, but streamed out as the bytes become available.  So <code>mpart-async</code> works with multiple internal streams of files and also provides a <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs">convenience wrapper</a> (if using tokio) for sending files given a path.</p>
<h2 id="a-new-example">A New Example</h2>
<p>All these changes to support <code>async fn</code> and is it actually easier to consume/use async libraries?</p>
<p>Given the <a href="https://crates.io/crates/hyper">hyper</a> example, I would say yes.</p>
<p>Compare the <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/examples/hyper.rs">new example</a>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">#[</span><span style="color:#bf616a;">tokio</span><span style="color:#c0c5ce;">::</span><span style="color:#bf616a;">main</span><span style="color:#c0c5ce;">]
async </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() -&gt; Result&lt;(), Error&gt; {
    </span><span style="color:#65737e;">//Setup a mock server to accept connections.
    //....

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client = Client::new();

    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> mpart = MultipartRequest::default();

    mpart.</span><span style="color:#96b5b4;">add_field</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">foo</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">bar</span><span style="color:#c0c5ce;">&quot;);
    mpart.</span><span style="color:#96b5b4;">add_file</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">test</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">Cargo.toml</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> request = Request::post(&quot;</span><span style="color:#a3be8c;">http://localhost:3000</span><span style="color:#c0c5ce;">&quot;)
        .</span><span style="color:#96b5b4;">header</span><span style="color:#c0c5ce;">(
            </span><span style="color:#d08770;">CONTENT_TYPE</span><span style="color:#c0c5ce;">,
            format!(&quot;</span><span style="color:#a3be8c;">multipart/form-data; boundary=</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, mpart.</span><span style="color:#96b5b4;">get_boundary</span><span style="color:#c0c5ce;">()),
        )
        .</span><span style="color:#96b5b4;">body</span><span style="color:#c0c5ce;">(Body::wrap_stream(mpart))?;

    client.</span><span style="color:#96b5b4;">request</span><span style="color:#c0c5ce;">(request).await?;

    Ok(())
}
</span></pre>
<p>With the <a href="https://github.com/cetra3/mpart-async/blob/c928f015fa31cd57533d4ba43551a9a96b61b0a2/examples/hyper.rs">older one</a>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#65737e;">// current_thread::Runtime can&#39;t be used because of the blocking file operations
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> rt = Runtime::new().</span><span style="color:#96b5b4;">expect</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">new rt</span><span style="color:#c0c5ce;">&quot;);

    </span><span style="color:#65737e;">//Setup a mock server to accept connections.
    //....

    // Open `Cargo.toml` file and create a request
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> request = File::open(&quot;</span><span style="color:#a3be8c;">Cargo.toml</span><span style="color:#c0c5ce;">&quot;)
        .</span><span style="color:#96b5b4;">map_err</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">e</span><span style="color:#c0c5ce;">| format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, e))
        .</span><span style="color:#96b5b4;">and_then</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">| {
            </span><span style="color:#65737e;">// A Stream of BytesMut decoded from an AsyncRead
            </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> framed = FramedRead::new(file, BytesCodec::new());

            </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> mpart = MultipartRequest::default();
            mpart.</span><span style="color:#96b5b4;">add_field</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">foo</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">bar</span><span style="color:#c0c5ce;">&quot;);
            mpart.</span><span style="color:#96b5b4;">add_stream</span><span style="color:#c0c5ce;">(
                &quot;</span><span style="color:#a3be8c;">foofile</span><span style="color:#c0c5ce;">&quot;,
                &quot;</span><span style="color:#a3be8c;">Cargo.toml</span><span style="color:#c0c5ce;">&quot;,
                &quot;</span><span style="color:#a3be8c;">application/toml</span><span style="color:#c0c5ce;">&quot;,
                framed.</span><span style="color:#96b5b4;">map</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">| b.</span><span style="color:#96b5b4;">freeze</span><span style="color:#c0c5ce;">()),
            );
            Request::post(&quot;</span><span style="color:#a3be8c;">http://localhost:3000</span><span style="color:#c0c5ce;">&quot;)
                .</span><span style="color:#96b5b4;">header</span><span style="color:#c0c5ce;">(
                    </span><span style="color:#d08770;">CONTENT_TYPE</span><span style="color:#c0c5ce;">,
                    format!(&quot;</span><span style="color:#a3be8c;">multipart/form-data; boundary=</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, mpart.</span><span style="color:#96b5b4;">get_boundary</span><span style="color:#c0c5ce;">()),
                ).</span><span style="color:#96b5b4;">body</span><span style="color:#c0c5ce;">(Body::wrap_stream(mpart))
                .</span><span style="color:#96b5b4;">into_future</span><span style="color:#c0c5ce;">()
                .</span><span style="color:#96b5b4;">map_err</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">e</span><span style="color:#c0c5ce;">| format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, e))
        });

    </span><span style="color:#65737e;">// Send request
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> task = request.</span><span style="color:#96b5b4;">and_then</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">request</span><span style="color:#c0c5ce;">| {
        </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> client = hyper::Client::new();
        client
            .</span><span style="color:#96b5b4;">request</span><span style="color:#c0c5ce;">(request)
            .</span><span style="color:#96b5b4;">map_err</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">e</span><span style="color:#c0c5ce;">| format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, e))
            .</span><span style="color:#96b5b4;">and_then</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">response</span><span style="color:#c0c5ce;">| {
                response
                    .</span><span style="color:#96b5b4;">into_body</span><span style="color:#c0c5ce;">()
                    .</span><span style="color:#96b5b4;">concat2</span><span style="color:#c0c5ce;">()
                    .</span><span style="color:#96b5b4;">map_err</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">e</span><span style="color:#c0c5ce;">| format!(&quot;</span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, e))
                    .</span><span style="color:#96b5b4;">and_then</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">body</span><span style="color:#c0c5ce;">| {
                        </span><span style="color:#b48ead;">if let </span><span style="color:#c0c5ce;">Ok(data) = </span><span style="color:#b48ead;">str</span><span style="color:#c0c5ce;">::from_utf8(&amp;body) {
                            println!(&quot;</span><span style="color:#a3be8c;">Response: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, data);
                        }
                        Ok(())
                    })
            })
    });

    rt.</span><span style="color:#96b5b4;">block_on</span><span style="color:#c0c5ce;">(task).</span><span style="color:#96b5b4;">expect</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">request failed</span><span style="color:#c0c5ce;">&quot;);
}
</span></pre>
<p>While there are still a few warts (such as having to manually add the boundary header), I find the code a lot more readable and easy to follow, rather than your standard combinator paths.</p>
<h2 id="no-more-error-associated-type">No more <code>Error</code> Associated Type</h2>
<p>The most drastic change to the <code>Stream</code> trait is that there is no longer an <code>Error</code> associated type.  The old <code>Stream</code>/<code>Future</code> traits had both <code>Item</code> and <code>Error</code>, as it assumed that streams were always going to be fallible.  The new traits do away with the <code>Error</code> associated type.  Instead, if you want your <code>Stream</code> to possibly be an error then you need to return a <code>Result</code> as your <code>Item</code> type.</p>
<p>For the <code>Stream</code> trait, the method you implement has changed to <code>poll_next</code> and uses the <code>std::task::Poll</code> enum as a return type.</p>
<p>The <code>Poll</code> enum did feel a little inside out when I started using it, but makes sense in terms of there being no <code>Error</code> type.  You don't return a <code>Result&lt;Async&lt;Option&gt;, _&gt;...</code> you instead return a <code>Poll&lt;Option&lt;Result&lt;_,_&gt;&gt;&gt;</code>.</p>
<p>Generally, this means if you wrote this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">Ok(Async::Ready(Some(bytes)))
</span></pre>
<p>You instead will return:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">Poll::Ready(Some(Ok(bytes)))
</span></pre><h2 id="streamext-traits-and-friends"><code>StreamExt</code> traits and friends</h2>
<p>As a consequence of no <code>Error</code> associated type, and an example of different ergonomics, if you are dealing with <code>Result</code> items, you may want to use the <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html">TryStreamExt</a> trait instead of <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.StreamExt.html">StreamExt</a>.  They are basically the same trait but one deals with <code>Result</code> a bit more nicely.  I'm not sure whether a simpler solution will be possible with higher kinded types in the future, but for now it is a tiny bit more complex than futures 0.1.</p>
<p>Interestingly, the <a href="https://docs.rs/futures/0.3.1/futures/stream/index.html">index page</a> for stream docs doesn't currently mention that the <code>TryStreamExt</code> trait exists &amp; I only found out about it by asking questions in the <a href="https://discord.gg/tokio">discord chat</a>.</p>
<p>But wait, there is also <a href="https://docs.rs/tokio/0.2.10/tokio/stream/trait.StreamExt.html">StreamExt</a> from tokio  which is subtly different, but does as of <code>0.2.10</code> allow you to run <code>collect()</code> on <code>Result&lt;Bytes, _&gt;</code> item streams.</p>
<p>When would you use either <code>StreamExt</code>?  I would say that if you want to be more general, you should probably use the <code>futures</code>  implementation.  Bearing in mind you can't run <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html#method.try_collect"><code>try_collect()</code></a> on <code>Result&lt;Bytes, _&gt;</code> at the moment due to an <a href="https://github.com/tokio-rs/bytes/issues/324">outstanding issue</a> with the bytes crate.  Why does this matter? Well, <a href="https://hyper.rs/">hyper</a> passes around streams of <code>Result&lt;Bytes, _&gt;</code> when you are streaming a body in &amp; out of a request.  Working with this particular stream signature is a bit clunky still, but I'm sure that this will be resolved in due course.</p>
<p>So we have:</p>
<ul>
<li><code>StreamExt</code> from <code>futures</code> that works on <code>Stream</code> that aren't <code>Result</code></li>
<li><code>TryStreamExt</code> from <code>futures</code> that works on <code>Stream</code> that are <code>Result</code> but doesn't work well with <code>Result&lt;Bytes,_&gt;</code> when trying to <code>try_collect()</code></li>
<li><code>StreamExt</code> from <code>tokio</code> that works with <code>Result&lt;Bytes,_&gt;</code> and allows you to <code>collect()</code> to get the output but now means you have a dependency on <code>tokio</code></li>
</ul>
<p>This might end up confusing more than just me, and I do hope that it's simplified in the future.</p>
<p>Luckily in the core of the API I don't need to use them, only for tests &amp; filestream, which means I'm quite happy to depend on the <code>tokio</code> implementation.</p>
<h2 id="wrapping-inner-streams-in-pin">Wrapping inner streams in <code>Pin</code></h2>
<p>I got tripped up on this for a while, and needed to again ask in chat for the answer here. If you have an inner stream and you want to call <code>poll_next</code> on it, you need to wrap it in a <code>Pin</code>, otherwise the <code>Stream</code> trait does not stick and you will get some gnarly error message with some weird suggestions:</p>
<p>The my original shot at the code was:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">stream.stream.</span><span style="color:#96b5b4;">poll_next</span><span style="color:#c0c5ce;">(cx)
</span></pre>
<p>But it needs to be:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Pin::new(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> stream.stream).</span><span style="color:#96b5b4;">poll_next</span><span style="color:#c0c5ce;">(cx)
</span></pre>
<p>The compiler error message is not too helpful here, and insists I restrict <code>S</code> by <code>Stream</code>, even though it is already restricted by <code>Stream</code>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">error[E0599]: no method named `poll_next` found for type `S` in the current scope
   --&gt; src/lib.rs:282:41
    |
282 |                     match stream.stream.poll_next(cx) {
    |                                         ^^^^^^^^^ method not found in `S`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `poll_next`, perhaps you need to restrict type parameter `S` with it:
    |
254 | impl&lt;E, S: futures::Stream + Stream&gt; Stream for MultipartRequest&lt;S&gt;
    |         ^^^^^^^^^^^^^^^^^^^^
</span></pre>
<p>You need to make sure that your inner stream implements <code>Unpin</code> as well to go down this path:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;E, S&gt; Stream </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">MultipartRequest&lt;S&gt;
</span><span style="color:#b48ead;">where</span><span style="color:#c0c5ce;">
    S: Stream&lt;Item = Result&lt;Bytes, E&gt;&gt; + Unpin,
</span></pre><h2 id="storing-the-results-from-an-async-fn-in-a-struct">Storing the results from an <code>async fn</code> in a struct</h2>
<p>Some of the methods in tokio are returns from an <code>async fn</code> , like the <a href="https://docs.rs/tokio/0.2.10/tokio/fs/struct.File.html#method.open">File::open</a> method, which I use for <code>FileStream</code>.  I found the answer on <a href="https://stackoverflow.com/questions/58354633/cannot-use-impl-future-to-store-async-function-in-a-vector">stack overflow</a> as to how to do this with <code>std::future</code>, since <code>async fn</code> returns an opaque type.</p>
<p>For the older version, the OpenFuture was a concrete type:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">FileStream {
    </span><span style="color:#bf616a;">inner</span><span style="color:#c0c5ce;">: Option&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
    </span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">: OpenFuture&lt;PathBuf&gt;,
}
</span></pre>
<p>The newer version is a return from an <code>async fn</code> and is opaque, so we wrap it using <code>Box::pin</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">FileStream {
    </span><span style="color:#bf616a;">inner</span><span style="color:#c0c5ce;">: Option&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
    </span><span style="color:#bf616a;">file</span><span style="color:#c0c5ce;">: Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;File, Error&gt;&gt; + Send + Sync&gt;&gt;,
}
</span></pre>
<p>You can then instantiate this with:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Box::pin(File::open(file.</span><span style="color:#96b5b4;">into</span><span style="color:#c0c5ce;">()))
</span></pre>
<p>Then it's easy to call passing on the context from an existing <code>poll()</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.file.</span><span style="color:#96b5b4;">as_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">poll</span><span style="color:#c0c5ce;">(cx)
</span></pre><h2 id="notifying-a-task">Notifying a task</h2>
<p><code>FileStream</code> has two stages.  One is the future to open the file. The second is streaming out the bytes of the file.  When the future resolves to open the file, I want to notify the context that it should be polled again to start streaming.</p>
<p>The old way of doing this was <code>task::current().notify()</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.inner = Some(FramedRead::new(file, BytesCodec::new()));
task::current().</span><span style="color:#96b5b4;">notify</span><span style="color:#c0c5ce;">();
</span></pre>
<p>The new way appears to be using  <code>cx.waker().wake_by_ref()</code> where <code>cx</code> is the context received from the poll:</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.inner = Some(FramedRead::new(file, BytesCodec::new()));
cx.</span><span style="color:#96b5b4;">waker</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">wake_by_ref</span><span style="color:#c0c5ce;">();
</span></pre>
<p>I say appears because the test written works without <code>wake_by_ref()</code> being called.  Requires a bit more investigation here I think to know exactly what's going on.  My <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs#L56">simple test example</a> works either way, strangely.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is not too onerous to convert to <code>std::future</code> for an existing library.  I would assume the leap from the old <code>tokio-core</code> would be harder, as the changes <em>feel</em> mostly cosmetic here.</p>
<p>The omission of the <code>Error</code> associated type to me actually makes things less ergonomic and things a little more fragmented (as evidenced by 3 <code>*StreamExt</code> traits..).  I was an advocate of this initially, but there probably needs to be a bit more work in making this nicer.</p>
<p>There are still a lot of libraries out there that will be required to be updated, a lot of old blogs that are no longer relevant, and a lot of exploration that needs to be done to see how the async ecosystem falls out.  But considering the friction of updating is quite small, I am quitely optimistic!</p>


</div>

    </div>
</body>

</html>