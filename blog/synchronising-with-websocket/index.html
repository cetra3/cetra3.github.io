<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronizing state with Websockets and JSON Patch</title>
    <meta name="description" content="A simple and extendable, almost realtime, state-sharing method for frontend and backend" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:0.67em 0}figcaption,figure,main{display:block}hr{box-sizing:content-box;height:0;overflow:visible}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}address{font-style:normal}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:"SF Mono","Segoe UI Mono","Roboto Mono",Menlo,Courier,monospace;font-size:1em}dfn{font-style:italic}small{font-size:80%;font-weight:400}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}fieldset{border:0;margin:0;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item;outline:none}canvas{display:inline-block}template{display:none}[hidden]{display:none}*,*::before,*::after{box-sizing:inherit}html{box-sizing:border-box;font-size:20px;line-height:1.5;-webkit-tap-highlight-color:transparent}body{background:#303742;color:#fff;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;font-size:.8rem;overflow-x:hidden;text-rendering:optimizeLegibility}a{color:#73c6ec;outline:none;text-decoration:none}a:focus{box-shadow:0 0 0 0.1rem rgba(115,198,236,0.2)}a:focus,a:hover,a:active,a.active{color:#46b4e6;text-decoration:underline}a:visited{color:#a0d8f2}h1,h2,h3,h4,h5,h6{color:inherit;font-weight:700;line-height:1.2;margin-bottom:.5rem;margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{font-weight:700}h1,.h1{font-size:2rem}h2,.h2{font-size:1.6rem}h3,.h3{font-size:1.4rem}h4,.h4{font-size:1.2rem}h5,.h5{font-size:1rem}h6,.h6{font-size:.8rem}p{margin:0 0 1.2rem}a,ins,u{text-decoration-skip:ink edges}abbr[title]{border-bottom:.05rem dotted;cursor:help;text-decoration:none}kbd{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#303742;color:#fff;font-size:.7rem}mark{background:#ffe9b3;color:#fff;border-bottom:.05rem solid #ffd367;border-radius:.1rem;padding:.05rem .1rem 0}blockquote{border-left:.1rem solid #dadee4;margin-left:0;padding:.4rem .8rem}blockquote p:last-child{margin-bottom:0}ul,ol{margin:.8rem 0 .8rem .8rem;padding:0}ul ul,ul ol,ol ul,ol ol{margin:.8rem 0 .8rem .8rem}ul li,ol li{margin-top:.4rem}ul{list-style:disc inside}ul ul{list-style-type:circle}ol{list-style:decimal inside}ol ol{list-style-type:lower-alpha}dl dt{font-weight:bold}dl dd{margin:.4rem 0 .8rem 0}.btn{appearance:none;background:#fff;border:.05rem solid #73c6ec;border-radius:.1rem;color:#73c6ec;cursor:pointer;display:inline-block;font-size:.8rem;height:2.5rem;line-height:1.2rem;outline:none;padding:.6rem .4rem;text-align:center;text-decoration:none;transition:background .2s, border .2s, box-shadow .2s, color .2s;user-select:none;vertical-align:middle;white-space:nowrap}.btn:focus{box-shadow:0 0 0 0.1rem rgba(115,198,236,0.2)}.btn:focus,.btn:hover{background:#fff;border-color:#66c1ea;text-decoration:none}.btn:active,.btn.active{background:#66c1ea;border-color:#4fb7e7;color:#fff;text-decoration:none}.btn.loading:active::after,.btn.active.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn[disabled],.btn:disabled,.btn.disabled{cursor:default;opacity:.5;pointer-events:none}.btn.btn-primary{background:#73c6ec;border-color:#66c1ea;color:#fff}.btn.btn-primary:focus,.btn.btn-primary:hover{background:#5dbde9;border-color:#4fb7e7;color:#fff}.btn.btn-primary:active,.btn.btn-primary.active{background:#54b9e8;border-color:#46b4e6;color:#fff}.btn.btn-primary.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-success{background:#32b643;border-color:#2faa3f;color:#fff}.btn.btn-success:focus{box-shadow:0 0 0 0.1rem rgba(50,182,67,0.2)}.btn.btn-success:focus,.btn.btn-success:hover{background:#30ae40;border-color:#2da23c;color:#fff}.btn.btn-success:active,.btn.btn-success.active{background:#2a9a39;border-color:#278e34;color:#fff}.btn.btn-success.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-error{background:#e85600;border-color:#d95000;color:#fff}.btn.btn-error:focus{box-shadow:0 0 0 0.1rem rgba(232,86,0,0.2)}.btn.btn-error:focus,.btn.btn-error:hover{background:#de5200;border-color:#cf4d00;color:#fff}.btn.btn-error:active,.btn.btn-error.active{background:#c44900;border-color:#b54300;color:#fff}.btn.btn-error.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-link{background:transparent;border-color:transparent;color:#73c6ec}.btn.btn-link:focus,.btn.btn-link:hover,.btn.btn-link:active,.btn.btn-link.active{color:#46b4e6}.btn.btn-sm{font-size:.7rem;height:1.4rem;padding:.05rem .3rem}.btn.btn-lg{font-size:.9rem;height:2rem;padding:.35rem .6rem}.btn.btn-block{display:block;width:100%}.btn.btn-action{width:2.5rem;padding-left:0;padding-right:0}.btn.btn-action.btn-sm{width:1.4rem}.btn.btn-action.btn-lg{width:2rem}.btn.btn-clear{background:transparent;border:0;color:currentColor;height:1rem;line-height:.8rem;margin-left:.2rem;margin-right:-2px;opacity:1;padding:.1rem;text-decoration:none;width:1rem}.btn.btn-clear:focus,.btn.btn-clear:hover{background:rgba(48,55,66,0.5);opacity:.95}.btn.btn-clear::before{content:"\2715"}.btn-group{display:inline-flex;flex-wrap:wrap}.btn-group .btn{flex:1 0 auto}.btn-group .btn:first-child:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group .btn:not(:first-child):not(:last-child){border-radius:0;margin-left:-.05rem}.btn-group .btn:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-.05rem}.btn-group .btn:focus,.btn-group .btn:hover,.btn-group .btn:active,.btn-group .btn.active{z-index:1}.btn-group.btn-group-block{display:flex}.btn-group.btn-group-block .btn{flex:1 0 0}.label{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#39414e;color:#e6e6e6;display:inline-block}.label.label-rounded{border-radius:5rem;padding-left:.4rem;padding-right:.4rem}.label.label-primary{background:#0b3e55;color:#fff}.label.label-secondary{background:#fff;color:#73c6ec}.label.label-success{background:#32b643;color:#fff}.label.label-warning{background:#ffb700;color:#fff}.label.label-error{background:#e85600;color:#fff}p code{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#0f4e6b;color:#fff;font-size:85%}.code{border-radius:.1rem;color:#fff;position:relative}.code::before{color:#bcc3ce;content:attr(data-lang);font-size:.7rem;position:absolute;right:.4rem;top:.1rem}.code code{background:#303742;color:inherit;display:block;line-height:1.5;overflow-x:auto;padding:1rem;width:100%}.container{margin-left:auto;margin-right:auto;padding-left:.4rem;padding-right:.4rem;width:100%}.container.grid-xl{max-width:1296px}.container.grid-lg{max-width:976px}.container.grid-md{max-width:856px}.container.grid-sm{max-width:616px}.container.grid-xs{max-width:496px}.show-xs,.show-sm,.show-md,.show-lg,.show-xl{display:none !important}.columns{display:flex;flex-wrap:wrap;margin-left:-.4rem;margin-right:-.4rem}.columns.col-gapless{margin-left:0;margin-right:0}.columns.col-gapless>.column{padding-left:0;padding-right:0}.columns.col-oneline{flex-wrap:nowrap;overflow-x:auto}.column{flex:1;max-width:100%;padding-left:.4rem;padding-right:.4rem}.column.col-12,.column.col-11,.column.col-10,.column.col-9,.column.col-8,.column.col-7,.column.col-6,.column.col-5,.column.col-4,.column.col-3,.column.col-2,.column.col-1{flex:none}.col-12{width:100%}.col-11{width:91.66666667%}.col-10{width:83.33333333%}.col-9{width:75%}.col-8{width:66.66666667%}.col-7{width:58.33333333%}.col-6{width:50%}.col-5{width:41.66666667%}.col-4{width:33.33333333%}.col-3{width:25%}.col-2{width:16.66666667%}.col-1{width:8.33333333%}.col-auto{flex:0 0 auto;max-width:none;width:auto}.col-mx-auto{margin-left:auto;margin-right:auto}.col-ml-auto{margin-left:auto}.col-mr-auto{margin-right:auto}@media (max-width: 1280px){.col-xl-12,.col-xl-11,.col-xl-10,.col-xl-9,.col-xl-8,.col-xl-7,.col-xl-6,.col-xl-5,.col-xl-4,.col-xl-3,.col-xl-2,.col-xl-1{flex:none}.col-xl-12{width:100%}.col-xl-11{width:91.66666667%}.col-xl-10{width:83.33333333%}.col-xl-9{width:75%}.col-xl-8{width:66.66666667%}.col-xl-7{width:58.33333333%}.col-xl-6{width:50%}.col-xl-5{width:41.66666667%}.col-xl-4{width:33.33333333%}.col-xl-3{width:25%}.col-xl-2{width:16.66666667%}.col-xl-1{width:8.33333333%}.hide-xl{display:none !important}.show-xl{display:block !important}}@media (max-width: 960px){.col-lg-12,.col-lg-11,.col-lg-10,.col-lg-9,.col-lg-8,.col-lg-7,.col-lg-6,.col-lg-5,.col-lg-4,.col-lg-3,.col-lg-2,.col-lg-1{flex:none}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.hide-lg{display:none !important}.show-lg{display:block !important}}@media (max-width: 840px){.col-md-12,.col-md-11,.col-md-10,.col-md-9,.col-md-8,.col-md-7,.col-md-6,.col-md-5,.col-md-4,.col-md-3,.col-md-2,.col-md-1{flex:none}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.hide-md{display:none !important}.show-md{display:block !important}}@media (max-width: 600px){.col-sm-12,.col-sm-11,.col-sm-10,.col-sm-9,.col-sm-8,.col-sm-7,.col-sm-6,.col-sm-5,.col-sm-4,.col-sm-3,.col-sm-2,.col-sm-1{flex:none}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.hide-sm{display:none !important}.show-sm{display:block !important}}@media (max-width: 480px){.col-xs-12,.col-xs-11,.col-xs-10,.col-xs-9,.col-xs-8,.col-xs-7,.col-xs-6,.col-xs-5,.col-xs-4,.col-xs-3,.col-xs-2,.col-xs-1{flex:none}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.hide-xs{display:none !important}.show-xs{display:block !important}}.navbar{align-items:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin-left:auto;margin-right:auto;max-width:960px}.navbar .navbar-section{align-items:center;display:flex;flex:1 0 0}.navbar .navbar-section:not(:first-child):last-child{justify-content:flex-end}.navbar .navbar-center{align-items:center;display:flex;flex:0 0 auto}.navbar .navbar-brand{font-size:.9rem;text-decoration:none}pre{padding:0.5rem 0.5rem;border-radius:.3rem;overflow-y:auto}.post header{border-radius:.3rem;padding:0.5rem;margin-bottom:0.5rem}.post header h1{margin-bottom:0}.post section{padding:0.5rem;background-color:#2a3039;border-radius:.3rem}.post img{width:100%}.post .utterances{max-width:none !important}.card{margin-bottom:0.5rem}.main-header{margin-bottom:0.5rem;background-color:#272d36;box-shadow:0 20rem 20rem 20rem rgba(115,198,236,0.2)}.card{background:#2a3039;border-radius:.3rem;display:flex;flex-direction:column}.card .card-header,.card .card-body,.card .card-footer{padding:.8rem;padding-bottom:0}.card .card-header:last-child,.card .card-body:last-child,.card .card-footer:last-child{padding-bottom:.8rem}.card .card-body{flex:1 1 auto}.card .card-image{padding-top:.8rem}.card .card-image:first-child{padding-top:0}.card .card-image:first-child img{border-top-left-radius:.1rem;border-top-right-radius:.1rem}.card .card-image:last-child img{border-bottom-left-radius:.1rem;border-bottom-right-radius:.1rem}
</style>
</head>

<body>
    <header class="main-header">
        <div class="navbar">
        <section class="navbar-section">
            <img src="/favicon.svg" width="30" height="30"/>
            <a href="/" class="btn btn-link">Home</a>
            <a href="/blog/" class="btn btn-link">Blogs</a>
            <a href="/rss.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
        </div>
    </header>
    <div class="container grid-lg">
        
<article class="post">
  <header>
  <h1>Synchronizing state with Websockets and JSON Patch </h1>
  <em>A simple and extendable, almost realtime, state-sharing method for frontend and backend</em>
  <br />
  
  <small class="label label-primary">rust</small> <small class="label">2023-01-29</small>
  
  </header>
  <section>
    <p>At <a href="https://www.formlogic.com/">formlogic</a>, we are using rust for a number of components within our tech stack, including: internal and external web applications, coordinating and logging machining workflows, parsing an industrial domain specific language (<a href="https://en.wikipedia.org/wiki/G-code">G-Code</a>), and more.</p>
<p>One of the challenges we faced early on was we had state that needed to be synchronized between rust applications, browsers and the database itself. We wanted to make sure that everyone could subscribe to state changes and everyone could have the same view. We also wanted the ability to roll back state, but preserve history i.e, have an append only immutable event log, while also being able to extend the structure of our state if we choose to in the future.</p>
<p>This blog will step through one possible solution for this challenge using a combination of <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a> for transport and <a href="http://jsonpatch.com/">JSON Patch</a> for describing changes to an arbitrary structure.</p>
<p>To provide an example of this, we'll be building up everyone's favourite <strong>Todo Application</strong>: a list of todos with a mark to say whether they're completed or not. However, our version will ensure that all connected clients will, in close to real time, have updates shown.</p>
<p>For those wanting to skip ahead and see the finished product, you can <a href="https://github.com/cetra3/websocket_jsonpatch/">view the source here</a>.</p>
<p><video width="100%" autoplay loop src="/videos/websocket_jsonpatch.mp4" ></video></p>
<h2 id="what-is-json-patch">What is JSON Patch</h2>
<p><a href="http://jsonpatch.com/">JSON Patch</a> is an RFC standard for describing patch updates to an arbitrary JSON structure.</p>
<p>For instance, if you had a JSON object that looked like this:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  </span><span style="color:#bae67e;">&quot;name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Hello&quot;
</span><span>}
</span></code></pre>
<p>And a patch that looks like this:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>[
</span><span>  {
</span><span>    </span><span style="color:#bae67e;">&quot;op&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;replace&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#bae67e;">&quot;path&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;/name&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#bae67e;">&quot;value&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Hello World!&quot;
</span><span>  }
</span><span>]
</span></code></pre>
<p>Then applying this patch, your object will now look like this:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  </span><span style="color:#bae67e;">&quot;name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Hello World!&quot;
</span><span>}
</span></code></pre>
<p>Another way to think about it, is that JSON Patch can encode transitions of state, and can be considered a lightweight form of <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>.</p>
<p>There are a number of libraries available in all languages, including <a href="https://github.com/idubrov/json-patch">rust</a> and for <a href="https://github.com/Starcounter-Jack/JSON-Patch">browsers</a>, and as the format itself is just JSON, it makes it easy to save the patches themselves in <code>jsonb</code> column on your database.</p>
<p>JSON Patch does not, by itself, enforce any schema for the JSON document. There are some operations that can cause an error if applied incorrectly, such as out of bounds replacements in arrays, but nothing that enforces that the end result is what you are expecting. For that purpose we're going to leverage <a href="https://github.com/serde-rs/serde"><code>serde</code></a> for its great type safety, ensuring our state is in the shape we want.</p>
<h2 id="websockets-and-updates">WebSockets and Updates</h2>
<p>With JSON Patch we have a stream of changes to a structure we can act upon, but how do we transport it? Well, since we want browsers to be a part of this as well, a great candidate is <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSockets</a>. WebSockets are a great way to stream things into a frontend without having the overhead of having a HTTP Connection per message. This channel can stay open for as long as the browser is open. We can receive also messages in near real time: only network latency and a bit of decoding act as a bottleneck.</p>
<p>Luckily WebSocket support is not only a feature of backend frameworks, but also has clients suited to connecting as well. We'll only be investigating browsers in this blog for brevity, but one could easily expand it to use something like <a href="https://github.com/snapview/tokio-tungstenite"><code>tokio-tungstenite</code></a> to consume our messages in rust.</p>
<h2 id="rust-backend">Rust Backend</h2>
<p>For brevity's sake we will choose <code>axum</code> as the backend, and their <a href="https://github.com/tokio-rs/axum/tree/main/examples/websockets">websockets example</a> as the base. For this example to build by itself, there are a few dependent crates:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#73d0ff;">axum </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;0.6.4&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;ws&quot;</span><span>]}
</span><span style="color:#73d0ff;">tokio </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;1&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;full&quot;</span><span>] }
</span></code></pre>
<p>The <code>ws</code> feature adds in websocket support to axum, otherwise all we'll use the defaults</p>
<p>For debug logs, we'll use <a href="https://github.com/tokio-rs/tracing"><code>tracing</code></a> with <code>tracing-subscriber</code> to get things logged nicely to stderr:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#73d0ff;">tracing </span><span>= </span><span style="color:#bae67e;">&quot;0.1.37&quot;
</span><span style="color:#73d0ff;">tracing-subscriber </span><span>= </span><span style="color:#bae67e;">&quot;0.3.16&quot;
</span></code></pre>
<p>And for our example we're going to use <code>serde</code> and <code>serde_json</code> for serialization, with <code>json-patch</code> as mentioned above. We'll also include the <code>futures</code> crate, as we'll see that comes in use later when we want to split the rx/tx of a websocket channel:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#73d0ff;">serde </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;1.0&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;derive&quot;</span><span>] }
</span><span style="color:#73d0ff;">serde_json </span><span>= </span><span style="color:#bae67e;">&quot;1.0&quot;
</span><span style="color:#73d0ff;">futures </span><span>= </span><span style="color:#bae67e;">&quot;0.3&quot;
</span><span style="color:#73d0ff;">json-patch </span><span>= </span><span style="color:#bae67e;">&quot;0.3.0&quot;
</span></code></pre>
<h3 id="the-main-method">The Main Method</h3>
<p>With the main method we want to instantiate some logging, set up our routes for our web app &amp; then serve on a port. While the initial example includes some static file hosting, we will skip those routes for brevity and only include the websocket route.</p>
<p>Our main function becomes quite concise:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span>() {
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Set a sensible default for logging to ensure we see something
</span><span>    </span><span style="color:#ffa759;">if </span><span>std</span><span style="color:#f29e74;">::</span><span>env</span><span style="color:#f29e74;">::</span><span>var_os(</span><span style="color:#bae67e;">&quot;RUST_LOG&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">is_none</span><span>() {
</span><span>        std</span><span style="color:#f29e74;">::</span><span>env</span><span style="color:#f29e74;">::</span><span>set_var(</span><span style="color:#bae67e;">&quot;RUST_LOG&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;websocket_jsonpatch=debug&quot;</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Initialise the `fmt` subscriber which will print logs to stderr
</span><span>    tracing_subscriber</span><span style="color:#f29e74;">::</span><span>fmt</span><span style="color:#f29e74;">::</span><span>init()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Add in our application with the websocket handler
</span><span>    </span><span style="color:#ffa759;">let</span><span> app </span><span style="color:#f29e74;">= </span><span>Router</span><span style="color:#f29e74;">::</span><span>new()
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">route</span><span>(</span><span style="color:#bae67e;">&quot;/ws&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f28779;">get</span><span>(ws_handler))
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Add in a shared websocket state struct `WsState`
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">layer</span><span>(Extension(Arc</span><span style="color:#f29e74;">::</span><span>new(WsState</span><span style="color:#f29e74;">::</span><span>new())))</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Listen on port 3333 for connections
</span><span>    </span><span style="color:#ffa759;">let</span><span> addr</span><span style="color:#ccc9c2cc;">:</span><span> SocketAddr </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;127.0.0.1:3333&quot;</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">parse</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#f28779;">debug!</span><span>(</span><span style="color:#bae67e;">&quot;Listening for requests on {}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> addr)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Start up the server
</span><span>    axum</span><span style="color:#f29e74;">::</span><span>Server</span><span style="color:#f29e74;">::</span><span>bind(</span><span style="color:#f29e74;">&amp;</span><span>addr)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">serve</span><span>(app</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_make_service</span><span>())
</span><span>        </span><span style="color:#f29e74;">.</span><span>await
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<h2 id="the-todo-struct">The Todo Struct</h2>
<p>Let's start shaping our todo struct:</p>
<ul>
<li>We want to name a todo list itself, such as <code>Shopping List</code> or <code>Writing a blog about Rust</code>. This also gives us an easy thing to update in the structure.</li>
<li>We want a list of entries, which have a name and a boolean as to whether they are marked <code>Completed</code> or not.</li>
<li>We want some convenience derives such as for serialization with serde and sensible defaults.</li>
</ul>
<p>With that in mind, we have the main <code>Todo</code> struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(Serialize</span><span style="color:#ccc9c2cc;">,</span><span> Deserialize</span><span style="color:#ccc9c2cc;">,</span><span> Default</span><span style="color:#ccc9c2cc;">,</span><span> Debug</span><span style="color:#ccc9c2cc;">,</span><span> Clone)]
</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">Todo </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// The main name of the todo list
</span><span>    name</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// The list of todos
</span><span>    todos</span><span style="color:#ccc9c2cc;">: </span><span>BTreeMap&lt;</span><span style="color:#ffa759;">u32</span><span>, TodoRow&gt;,
</span><span>}
</span></code></pre>
<p>And each Row has the following shape:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(Serialize</span><span style="color:#ccc9c2cc;">,</span><span> Deserialize</span><span style="color:#ccc9c2cc;">,</span><span> Default</span><span style="color:#ccc9c2cc;">,</span><span> Debug</span><span style="color:#ccc9c2cc;">,</span><span> Clone)]
</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">TodoRow </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// The name of the specific todo
</span><span>    name</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Whether this todo is completed or not
</span><span>    completed</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">bool</span><span>,
</span><span>}
</span></code></pre>
<h4 id="a-note-on-using-a-btreemap-instead-of-a-vec">A Note on using a <code>BTreeMap</code> instead of a <code>Vec</code></h4>
<p>An initial version of this blog included todos as a <code>Vec&lt;TodoRow&gt;</code>, but that was found to be quite noisy when clearing out completed todos. Refactoring this to use a <code>BTreeMap</code> instead took not long at all, and is a testament to this design being malleable. Readers are invited to adjust this shape back to a <code>Vec</code> or provide other fields/values to see how to make such a change.</p>
<h3 id="making-changes">Making Changes</h3>
<p>If you have used the <a href="https://redux.js.org/">redux pattern</a> before, you would be familiar with use actions to mutate state. We'll build something similar here, to make it easier to describe the intent of the change and to have all the logic in one module. These actions are what are going to be sent from the browser or other clients.</p>
<p>When actions are received, the todo state is changed, and we generate a diff between the old and new JSON, which is then sent over the wire back to the frontend in the form of JSON Patches.</p>
<p>These changes are executed in serial by means of a held mutex, rather than allow concurrent updates to the state. We'll also only have one &quot;todo&quot; list, but could imagine an easy extension to have multiple different lists, each with their own changes. For concurrency without making changes serial, a <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDT</a> like <a href="https://github.com/automerge/automerge-rs"><code>automerge</code></a> could be a suitable candidate. In practice, we've found that, when given a low concurrent user count per JSON object, the simplicity and auditability of JSON patches is a great trade-off.</p>
<h3 id="actions">Actions</h3>
<p>We're going to have a few actions that are available to use (all of which should be self-descriptive):</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(Deserialize)]
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">serde</span><span>(tag </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;type&quot;</span><span>)]
</span><span style="color:#ffa759;">pub enum </span><span style="color:#73d0ff;">TodoAction </span><span>{
</span><span>    Add { row</span><span style="color:#ccc9c2cc;">:</span><span> TodoRow }</span><span style="color:#ccc9c2cc;">,
</span><span>    ChangeName { name</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">String </span><span>}</span><span style="color:#ccc9c2cc;">,
</span><span>    Update { index</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">u32</span><span style="color:#ccc9c2cc;">,</span><span> row</span><span style="color:#ccc9c2cc;">:</span><span> TodoRow }</span><span style="color:#ccc9c2cc;">,
</span><span>    Remove { index</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">u32 </span><span>}</span><span style="color:#ccc9c2cc;">,
</span><span>    RemoveCompleted</span><span style="color:#ccc9c2cc;">,
</span><span>}
</span></code></pre>
<p>We are using a tag to make it easier to define these in TypeScript later on. Serde will use a field named <code>type</code> to store the enum variant.</p>
<p>With those actions, we can then use them to apply to our <code>Todo</code> struct and update the state:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">Todo </span><span>{
</span><span>    </span><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">apply</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">action</span><span style="color:#ccc9c2cc;">:</span><span> TodoAction) {
</span><span>        </span><span style="color:#ffa759;">match</span><span> action {
</span><span>            TodoAction</span><span style="color:#f29e74;">::</span><span>Add { row } </span><span style="color:#f29e74;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#5c6773;">// Find the next available index
</span><span>                </span><span style="color:#ffa759;">let</span><span> index </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todos</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">keys</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">max</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">copied</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap_or_default</span><span>() </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">1</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>                </span><span style="font-style:italic;color:#5c6773;">// Insert this into our map
</span><span>                </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todos</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span>(index</span><span style="color:#ccc9c2cc;">,</span><span> row)</span><span style="color:#ccc9c2cc;">;
</span><span>            }
</span><span>            TodoAction</span><span style="color:#f29e74;">::</span><span>Update { row</span><span style="color:#ccc9c2cc;">,</span><span> index } </span><span style="color:#f29e74;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todos</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span>(index</span><span style="color:#ccc9c2cc;">,</span><span> row)</span><span style="color:#ccc9c2cc;">;
</span><span>            }
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// Change the name of the todo list
</span><span>            TodoAction</span><span style="color:#f29e74;">::</span><span>ChangeName { name } </span><span style="color:#f29e74;">=&gt; </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>name </span><span style="color:#f29e74;">=</span><span> name</span><span style="color:#ccc9c2cc;">,
</span><span>            TodoAction</span><span style="color:#f29e74;">::</span><span>Remove { index } </span><span style="color:#f29e74;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todos</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">remove</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>index)</span><span style="color:#ccc9c2cc;">;
</span><span>            }
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// Filter and remove all completed todo rows
</span><span>            TodoAction</span><span style="color:#f29e74;">::</span><span>RemoveCompleted </span><span style="color:#f29e74;">=&gt; </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todos</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">retain</span><span>(|_</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">val</span><span>| </span><span style="color:#f29e74;">!</span><span>val</span><span style="color:#f29e74;">.</span><span>completed)</span><span style="color:#ccc9c2cc;">,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="websockets">WebSockets</h2>
<p>We are going to use websockets as our primary means of communication between the front and backend, providing a bi-directional channel with which we can send messages.</p>
<h3 id="shared-wsstate">Shared WsState</h3>
<p>In the <code>main()</code> function, we added a reference counted <code>WsState</code> struct via <code>AddExtensionLayer</code>. This represents our shared state between all websocket sessions.</p>
<p>Inside this struct, we are going to keep two things:</p>
<ul>
<li>The <code>Todo</code> struct as per our modelling above inside a tokio <code>Mutex</code></li>
<li>A list of websocket <a href="https://docs.rs/futures/0.3.17/futures/sink/trait.Sink.html">sinks</a> that we can send updates to. So when one session makes a change, it is reflected on all other sessions.</li>
</ul>
<p>This struct looks like so:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">WsState </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Our main state, behind a tokio Mutex
</span><span>    todo</span><span style="color:#ccc9c2cc;">: </span><span>Mutex&lt;Todo&gt;,
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// A list of sessions we will send changes to
</span><span>    txs</span><span style="color:#ccc9c2cc;">: </span><span>Mutex&lt;</span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;SplitSink&lt;WebSocket, Message&gt;&gt;&gt;,
</span><span>}
</span></code></pre>
<h4 id="adding-sessions">Adding Sessions</h4>
<p>When we add a session, we want to send a full state to get it caught up, and then add it to our list:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">add_session</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">tx</span><span style="color:#ccc9c2cc;">: </span><span>SplitSink&lt;WebSocket, Message&gt;) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Get a mutable lock of our transactions
</span><span>    </span><span style="color:#ffa759;">let mut</span><span> txs </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>txs</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">lock</span><span>()</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Send the initial state update
</span><span>    </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Err</span><span>(err) </span><span style="color:#f29e74;">=</span><span> tx
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">send</span><span>(Message</span><span style="color:#f29e74;">::</span><span>Text(
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// This method will not fail in &quot;normal&quot; operations so an `expect()` is OK here
</span><span>            serde_json</span><span style="color:#f29e74;">::</span><span>to_string(</span><span style="color:#f29e74;">&amp;</span><span>ServerMessage</span><span style="color:#f29e74;">::</span><span>Full {
</span><span>                todo</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;*</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todo</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">lock</span><span>()</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#ccc9c2cc;">,
</span><span>            })
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span>(</span><span style="color:#bae67e;">&quot;Serialize Error&quot;</span><span>)</span><span style="color:#ccc9c2cc;">,
</span><span>        ))
</span><span>        </span><span style="color:#f29e74;">.</span><span>await
</span><span>    {
</span><span>        </span><span style="color:#f28779;">warn!</span><span>(</span><span style="color:#bae67e;">&quot;Could not send initial state update: {}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> err)</span><span style="color:#ccc9c2cc;">;
</span><span>        </span><span style="color:#ffa759;">return</span><span style="color:#ccc9c2cc;">;
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Add session to our list of sessions
</span><span>    txs</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(tx)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<h3 id="applying-state-changes">Applying State Changes</h3>
<p>On <code>WsState</code> we'll create a method called <code>apply</code> which takes a <code>TodoAction</code> and applies this to the state, then broadcasts changes to all connected sessions. We'll break this method down as there is a lot happening here.</p>
<p>The signature of this method looks like this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">apply</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">action</span><span style="color:#ccc9c2cc;">:</span><span> TodoAction) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;(), Error&gt; {
</span><span>
</span><span>    </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>The first thing we need to do is grab a mutable reference to our existing state:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> state </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>todo</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">lock</span><span>()</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Then we want to get a copy of the state as it stands currently, but as a <code>serde_json::Value</code> which we can use to diff:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> existing_json </span><span style="color:#f29e74;">= </span><span>serde_json</span><span style="color:#f29e74;">::</span><span>to_value(</span><span style="color:#f29e74;">&amp;*</span><span>state)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>After we have our <code>existing_json</code>, we can use the <code>Todo::apply()</code> method to mutate the value:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// Apply the action to our todo list.  This mutates it in place
</span><span>state</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">apply</span><span>(action)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>With that applied, we can grab the new state as a <code>Value</code> as well:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// Serialize out the new JSON for diffing
</span><span style="color:#ffa759;">let</span><span> new_json </span><span style="color:#f29e74;">= </span><span>serde_json</span><span style="color:#f29e74;">::</span><span>to_value(</span><span style="color:#f29e74;">&amp;*</span><span>state)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Then, we can use the <a href="https://docs.rs/json-patch/0.2.6/json_patch/fn.diff.html"><code>diff</code></a> method from <code>json_patch</code> to automatically generate the patches needed to go from the existing to the new state:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// Get the changes using the `diff` method from `json_patch`
</span><span style="color:#ffa759;">let</span><span> ops </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">diff</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>existing_json</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>new_json)</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>With this, you'll notice we are quite agnostic to what the shape is of the state, and how the state changes. All we need to be able to do is serialize it before and after, and we can completely change the structure internally. A further excercise would be to generalize this method to accept anything that implements <code>Serialize</code></p>
<p>Ok, we have a list of patches, let's print them out so we can inspect them:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f28779;">debug!</span><span>(</span><span style="color:#bae67e;">&quot;New Patches:{:?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> ops)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h4 id="broadcasting-our-changes">Broadcasting Our Changes</h4>
<p>Generating changes to state is one half of this method, the other half is to broadcast this out to every session.</p>
<p>We will first check whether there were any changes worth broadcasting, and then will serialize it to a string</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// If there are no changes, don&#39;t bother broadcasting
</span><span style="color:#ffa759;">if </span><span style="color:#f29e74;">!</span><span>ops</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">is_empty</span><span>() {
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Serialize it to a json string here
</span><span>    </span><span style="color:#ffa759;">let</span><span> message </span><span style="color:#f29e74;">= </span><span>serde_json</span><span style="color:#f29e74;">::</span><span>to_string(</span><span style="color:#f29e74;">&amp;</span><span>ServerMessage</span><span style="color:#f29e74;">::</span><span>Patch { ops })</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>The next thing we want to do is grab all of our sessions and lock them for the time being:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> txs </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>txs</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">lock</span><span>()</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Now, some session between now and the last broadcast could have gone away.</p>
<p>What we are going to do is take all the sessions out of the existing vec, replacing it with an empty one using <code>std::mem:take()</code>, and then try sending to each session. If there is no issue sending, we add it back to the list.</p>
<p>If there is an issue sending, we will log the error but not add it back, to be dropped/cleaned up when the object is out of scope:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// We take all the txs to iterate, and replace with an empty `Vec`
</span><span style="color:#ffa759;">for mut</span><span> tx </span><span style="color:#f29e74;">in </span><span>mem</span><span style="color:#f29e74;">::</span><span>take(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="color:#f29e74;">*</span><span>txs) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// If there is an issue sending a message we will warn about it
</span><span>    </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Err</span><span>(err) </span><span style="color:#f29e74;">=</span><span> tx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">send</span><span>(Message</span><span style="color:#f29e74;">::</span><span>Text(message</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span>()))</span><span style="color:#f29e74;">.</span><span>await {
</span><span>        </span><span style="color:#f28779;">warn!</span><span>(</span><span style="color:#bae67e;">&quot;Client disconnected: {}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> err)</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// If there is no issue sending, then we add it back to our `Vec`
</span><span>    } </span><span style="color:#ffa759;">else </span><span>{
</span><span>        txs</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(tx)
</span><span>    }
</span><span>}
</span></code></pre>
<p>And then we're done! To recap, when applying changes we first generate a list of patches to apply. We then send that list to all the connected sessions, cleaning up any erroneous sessions in the process.</p>
<h3 id="axum-websocket-interface">Axum Websocket Interface</h3>
<p>Axum provides a <code>WebSocketUpgrade</code> struct, with which you can feed it a function (or closure) to start an async task when the websocket upgrade happens. We use this to feed in our <code>WsState</code> value (behind an <code>Arc</code>):</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">ws_handler</span><span>(
</span><span>    </span><span style="color:#ffcc66;">ws</span><span style="color:#ccc9c2cc;">:</span><span> WebSocketUpgrade,
</span><span>    Extension(</span><span style="color:#ffcc66;">state</span><span>): Extension&lt;Arc&lt;WsState&gt;&gt;,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl IntoResponse {
</span><span>    </span><span style="color:#f28779;">debug!</span><span>(</span><span style="color:#bae67e;">&quot;New Websocket Connection&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>    ws</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">on_upgrade</span><span>(|</span><span style="color:#ffcc66;">socket</span><span>| </span><span style="color:#f28779;">handle_socket</span><span>(socket</span><span style="color:#ccc9c2cc;">,</span><span> state))
</span><span>}
</span></code></pre>
<h3 id="server-messages">Server Messages</h3>
<p>To keep things simple we will have an enum of possible messages the server/backend can send to clients. There are going to be only two types: a list of patches to apply or a full todo struct. When clients first connect, we need to get them caught up with the current state of the world, so we send them the full state.</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(Serialize</span><span style="color:#ccc9c2cc;">,</span><span> Debug)]
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">serde</span><span>(tag </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;type&quot;</span><span>)]
</span><span style="color:#ffa759;">enum </span><span style="color:#73d0ff;">ServerMessage</span><span>&lt;&#39;a&gt; {
</span><span>    Patch { ops</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;PatchOperation&gt; }</span><span style="color:#ccc9c2cc;">,
</span><span>    Full { todo</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">&#39;a</span><span> Todo }</span><span style="color:#ccc9c2cc;">,
</span><span>}
</span></code></pre>
<p>As per the <code>TodoAction</code> we'll use a <code>type</code> tag for ease of integration with TypeScript. Also notice that we will be able to send multiple patches in one message. This is for in the case of a change causing a cascade of patches, such as when removing completed items in the todo list.</p>
<p>This <code>ServerMessage</code> enum will be serialized on the wire as JSON. Websockets support standard text messages, as well as binary types. A further exercise would be to use a different encoding, such as <a href="https://cbor.io/"><code>CBOR</code></a>, but does make things a bit less human readable</p>
<h3 id="handle-socket">Handle Socket</h3>
<p>Our <code>handle_socket</code> method is responsible for initiating new session &amp; feeding that session into the <code>WsState</code> struct.</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub</span><span> async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">handle_socket</span><span>(</span><span style="color:#ffcc66;">socket</span><span style="color:#ccc9c2cc;">:</span><span> WebSocket, </span><span style="color:#ffcc66;">state</span><span style="color:#ccc9c2cc;">: </span><span>Arc&lt;WsState&gt;) {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Magic happens here
</span><span>}
</span></code></pre>
<p>Firstly, we'll split up the websocket into a tx/rx pair. We'll have the <code>handle_socket</code> hold onto the <code>rx</code> part, and move the <code>tx</code> into the <code>WsState</code> value. If you have a struct that implements <code>Stream</code> and <code>Sink</code> you can use futures and <code>StreamExt</code> to split this into two separate objects, with separate ownership of both.</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let </span><span>(tx</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffa759;">mut</span><span> rx) </span><span style="color:#f29e74;">=</span><span> socket</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">split</span><span>()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>We'll then add this session to our shared state:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>state</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_session</span><span>(tx)</span><span style="color:#f29e74;">.</span><span>await</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>This method will fire off a <code>ServerMessage::Full</code> with the current state, returning early if this fails</p>
<p>Then, we simply loop any messages received from the client &amp; apply them to our shared state. The type of messages we receive from the client will be our <code>TodoAction</code> enum.</p>
<p>To loop while there are messages, we can use the following <code>let</code> binding:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">while let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(msg)) </span><span style="color:#f29e74;">=</span><span> rx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">next</span><span>()</span><span style="color:#f29e74;">.</span><span>await {
</span><span>    </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>This loop will terminate if there are no more messages to receive (i.e, the stream is finished and returning <code>None</code>), and if there are any errors receiving messages.</p>
<p>Inside the loop, we decode the message as JSON, and throw a warning if it's a message we're not expecting. We then apply that message to our shared state. As above, the shared state will in turn broadcast out JSON patches to update the state:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// Loop until there are no messages or an error
</span><span style="color:#ffa759;">while let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span>(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(msg)) </span><span style="color:#f29e74;">=</span><span> rx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">next</span><span>()</span><span style="color:#f29e74;">.</span><span>await {
</span><span>    </span><span style="color:#ffa759;">if let </span><span>Message</span><span style="color:#f29e74;">::</span><span>Text(text) </span><span style="color:#f29e74;">=</span><span> msg {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Decode our message and warn if it&#39;s something we don&#39;t know about
</span><span>        </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(action) </span><span style="color:#f29e74;">= </span><span>serde_json</span><span style="color:#f29e74;">::</span><span>from_str</span><span style="color:#f29e74;">::</span><span>&lt;TodoAction&gt;(</span><span style="color:#f29e74;">&amp;</span><span>text) {
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// Apply the state, which will broadcast out changes as a JSON patch
</span><span>            </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Err</span><span>(err) </span><span style="color:#f29e74;">=</span><span> state</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">apply</span><span>(action)</span><span style="color:#f29e74;">.</span><span>await {
</span><span>                </span><span style="color:#f28779;">warn!</span><span>(</span><span style="color:#bae67e;">&quot;Error applying state:{}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> err)</span><span style="color:#ccc9c2cc;">;
</span><span>            }
</span><span>        } </span><span style="color:#ffa759;">else </span><span>{
</span><span>            </span><span style="color:#f28779;">warn!</span><span>(</span><span style="color:#bae67e;">&quot;Unknown action received:{}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> text)</span><span style="color:#ccc9c2cc;">;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Ok! So we have the shape of our data, some actions to mutate the state and some scaffolding to wire up the websockets. What's next is to build the frontend.</p>
<h2 id="react-frontend">React Frontend</h2>
<p>We're going to build a companion browser application to use our backend. This will be built in react, but could be built using any framework, or even vanilla javascript. <a href="https://vitejs.dev/">Vite</a> will be the build tool of choice, given it has a fast development feedback loop and supports React/TypeScript. For styling, we'll use <a href="https://picturepan2.github.io/spectre/">spectre.css</a> to make it look a little better than the standard style and provide some responsivness. You can create a new vite project by running:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>yarn create vite front --template react-ts
</span></code></pre>
<p>We'll want to run the rust backend in another terminal window with:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>cargo run
</span></code></pre>
<p>And then we want to proxy all requests to <code>/ws</code> to the backend which we can do by changing the <code>vite.config.ts</code>:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#ffa759;">export default </span><span style="color:#ffd580;">defineConfig</span><span>({
</span><span>  plugins</span><span style="color:#ccc9c2cc;">: </span><span>[</span><span style="color:#ffd580;">react</span><span>()]</span><span style="color:#ccc9c2cc;">,
</span><span>  server</span><span style="color:#ccc9c2cc;">: </span><span>{
</span><span>    proxy</span><span style="color:#ccc9c2cc;">: </span><span>{
</span><span>      </span><span style="color:#bae67e;">&quot;/ws&quot;</span><span style="color:#ccc9c2cc;">: </span><span>{
</span><span>        target</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;http://127.0.0.1:3333&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        ws</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">true</span><span style="color:#ccc9c2cc;">,
</span><span>      }</span><span style="color:#ccc9c2cc;">,
</span><span>    }</span><span style="color:#ccc9c2cc;">,
</span><span>  }</span><span style="color:#ccc9c2cc;">,
</span><span>})</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>With that in place, we can <code>yarn dev</code> to get up a developer window.</p>
<h3 id="todo-structure">Todo Structure</h3>
<p>We want to have the todo structure imitate what's in the backend. For brevity here we'll just write them by hand, but there does exist tools to have these structures generated automatically (see the blog: <a href="/blog/sharing-types-with-the-frontend/">Publishing Rust types to a TypeScript frontend</a>).</p>
<p>Starting off with the <code>Todo</code> struct itself:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">Todo </span><span>{
</span><span>  name</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">;
</span><span>  todos</span><span style="color:#f29e74;">: </span><span>{ [</span><span style="color:#ffcc66;">index</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span>]</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TodoRow </span><span>}</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">TodoRow </span><span>{
</span><span>  id</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">;
</span><span>  name</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">;
</span><span>  completed</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">boolean</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>Then, we deviate a little bit with the actions. In the backend we have used a tagged enum with the <code>type</code> property to define what action is in use. In typescript, we will use a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions"><strong>Discriminated Union</strong></a> pattern to define these actions in a compatible way:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">Add </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;Add&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  row</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TodoRow</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">ChangeName </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;ChangeName&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  name</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">string</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">Update </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;Update&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  row</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TodoRow</span><span style="color:#ccc9c2cc;">;
</span><span>  index</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">Remove </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;Remove&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  index</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export interface </span><span style="color:#73d0ff;">RemoveCompleted </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;RemoveCompleted&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">export type </span><span style="color:#73d0ff;">TodoAction </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">Add </span><span style="color:#f29e74;">| </span><span style="color:#73d0ff;">ChangeName </span><span style="color:#f29e74;">| </span><span style="color:#73d0ff;">Update </span><span style="color:#f29e74;">| </span><span style="color:#73d0ff;">Remove </span><span style="color:#f29e74;">| </span><span style="color:#73d0ff;">RemoveCompleted</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h3 id="websocket-component">Websocket Component</h3>
<p>For the Websocket component, we'll cheat a little bit and use some global variables to hold around both the websocket connection itself &amp; the shared state. Using react hooks we'll integrate with components to allow state changes to come through.</p>
<p>Firstly, we define our server messages as per the backend. We'll be using the same <strong>Discriminated Union</strong> pattern.</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">interface </span><span style="color:#73d0ff;">Patch </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;Patch&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// `Operation` from `fast-json-patch` module
</span><span>  ops</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Operation</span><span>[]</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">interface </span><span style="color:#73d0ff;">Full </span><span>{
</span><span>  type</span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;Full&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>  todo</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Todo</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">ServerMessage </span><span style="color:#f29e74;">= </span><span style="color:#73d0ff;">Patch </span><span style="color:#f29e74;">| </span><span style="color:#73d0ff;">Full</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Then, let's set up our global variables:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">let </span><span>websocket</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">WebSocket </span><span style="color:#f29e74;">| </span><span style="font-style:italic;color:#5ccfe6;">undefined</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">let </span><span>todo</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Todo </span><span style="color:#f29e74;">| </span><span style="font-style:italic;color:#5ccfe6;">undefined</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>We use <code>undefined</code> to indicate those values aren't initialised. Both the websocket &amp; the todo itself are initialised at different times.</p>
<p>Then, we'll create a <code>setupWebsocket</code> function which will handle the connection &amp; and plumbing needed to send and receive messages. We'll want to have a callback function to accept a new <code>todo</code> object which we'll use to integrate into react hooks later.</p>
<p>So with the the signature looks like the following:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">const </span><span style="color:#ffd580;">setupWebsocket </span><span style="color:#f29e74;">= </span><span>(</span><span style="color:#ffd580;">onTodoUpdate</span><span style="color:#f29e74;">: </span><span>(</span><span style="color:#ffcc66;">todo</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Todo</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span style="font-style:italic;color:#5ccfe6;">void</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>   </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>Then we want to create a new <code>WebSocket</code>, but we need to pass it a valid uri. Websockets use <code>ws://</code> instead of <code>http://</code> and <code>wss://</code> instead of <code>https://</code> for their URLs, so we'll split apart the current <code>window.location</code> and use components of it to build our uri:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">const </span><span>loc </span><span style="color:#f29e74;">= </span><span>window</span><span style="color:#f29e74;">.</span><span>location</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">const </span><span>uri </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">`${</span><span>loc</span><span style="color:#f29e74;">.</span><span style="color:#bae67e;">protocol </span><span style="color:#f29e74;">=== </span><span style="color:#bae67e;">&quot;https:&quot; </span><span style="color:#f29e74;">? </span><span style="color:#bae67e;">&quot;wss:&quot; </span><span style="color:#f29e74;">: </span><span style="color:#bae67e;">&quot;ws:&quot;}//${</span><span>loc</span><span style="color:#f29e74;">.</span><span style="color:#bae67e;">host}/ws`</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5ccfe6;">console</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">log</span><span>(</span><span style="color:#bae67e;">`Connecting websocket: ${</span><span>uri</span><span style="color:#bae67e;">}`</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">const </span><span>connection </span><span style="color:#f29e74;">= new </span><span style="color:#73d0ff;">WebSocket</span><span>(uri)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Ok, with our connection created we will need to listen to different events, and execute accordingly.</p>
<p>Firstly, when the connection is opened, we'll log that its connected and then set our global <code>websocket</code> variable equal to this connection:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span>connection</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">onopen </span><span style="color:#f29e74;">= </span><span>() </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5ccfe6;">console</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">log</span><span>(</span><span style="color:#bae67e;">&quot;Websocket Connected&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>  websocket </span><span style="color:#f29e74;">= </span><span>connection</span><span style="color:#ccc9c2cc;">;
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Now, there is a case that a websocket connection drops while you have the page open. We want to recover from this somewhat gracefully, retrying the connection until it's successful.</p>
<p>One way of doing this is to re-execute the <code>setupWebsocket</code> method after a bit of time has passed, and that's what we'll do here, retry the setup after half a second has passed. If the websocket has closed gracefully, then we don't bother retrying:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="font-style:italic;color:#5c6773;">// If we receive a close event the backend has gone away, we try reconnecting in a bit of time
</span><span>connection</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">onclose </span><span style="color:#f29e74;">= </span><span>(</span><span style="color:#ffcc66;">reason</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  websocket </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">undefined</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
</span><span>  </span><span style="color:#ffa759;">if </span><span>(reason</span><span style="color:#f29e74;">.</span><span>code </span><span style="color:#f29e74;">!== </span><span style="color:#ffcc66;">1000 </span><span style="color:#f29e74;">&amp;&amp; </span><span>reason</span><span style="color:#f29e74;">.</span><span>code </span><span style="color:#f29e74;">!== </span><span style="color:#ffcc66;">1001</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#5ccfe6;">console</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">error</span><span>(</span><span style="color:#bae67e;">&quot;Websocket connection closed&quot;</span><span style="color:#ccc9c2cc;">, </span><span>reason)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#f28779;">setTimeout</span><span>(() </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>      </span><span style="color:#ffd580;">setupWebsocket</span><span>(onTodoUpdate)</span><span style="color:#ccc9c2cc;">;
</span><span>    }</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">500</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>  }
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Then, if there is an error with the websocket we can log what that error is, then close it</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span>connection</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">onerror </span><span style="color:#f29e74;">= </span><span>(</span><span style="color:#ffcc66;">error</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5ccfe6;">console</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">error</span><span>(</span><span style="color:#bae67e;">&quot;Error with websocket&quot;</span><span style="color:#ccc9c2cc;">, </span><span>error)</span><span style="color:#ccc9c2cc;">;
</span><span>  connection</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">close</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Ok with the websocket life cycle out of the way, now comes to the meat of our event loop. What we're going to do is listen for server events, and if either type is received, act accordingly:</p>
<ul>
<li>For the <code>Full</code> server message, the <code>todo</code> object will be replaced outright.</li>
<li>For the <code>Patch</code>, we will use the <code>fast-json-patch</code> module to mutate <code>todo</code> in place, and then execute our callback:</li>
</ul>
<p>Whatever the type of message, the full <code>todo</code> object is provided to the callback, with the patch merging logic happening here, and shielded from our callback update.</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span>connection</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">onmessage </span><span style="color:#f29e74;">= </span><span>(</span><span style="color:#ffcc66;">message</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// Parse the message via JSON, asserting what we&#39;ll get from the backend
</span><span>  </span><span style="color:#ffa759;">const </span><span>msg </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#f29e74;">JSON</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">parse</span><span>(message</span><span style="color:#f29e74;">.</span><span>data) </span><span style="color:#ffa759;">as </span><span style="color:#73d0ff;">ServerMessage</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="color:#ffa759;">switch </span><span>(msg</span><span style="color:#f29e74;">.</span><span>type) {
</span><span>    </span><span style="color:#ffa759;">case </span><span style="color:#bae67e;">&quot;Patch&quot;</span><span>: {
</span><span>      </span><span style="font-style:italic;color:#5c6773;">// Mutate the todo state in place, and then send an update
</span><span>      </span><span style="color:#ffa759;">if </span><span>(todo </span><span style="color:#f29e74;">!== </span><span style="color:#ffcc66;">undefined</span><span>) {
</span><span>        </span><span style="color:#ffa759;">let </span><span>{ newDocument: newTodo } </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">applyPatch</span><span>(todo</span><span style="color:#ccc9c2cc;">, </span><span>msg</span><span style="color:#f29e74;">.</span><span>ops</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">false</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">false</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        </span><span style="color:#ffd580;">onTodoUpdate</span><span>(newTodo)</span><span style="color:#ccc9c2cc;">;
</span><span>        todo </span><span style="color:#f29e74;">= </span><span>newTodo</span><span style="color:#ccc9c2cc;">;
</span><span>      }
</span><span>      </span><span style="color:#ffa759;">break</span><span style="color:#ccc9c2cc;">;
</span><span>    }
</span><span>    </span><span style="color:#ffa759;">case </span><span style="color:#bae67e;">&quot;Full&quot;</span><span>: {
</span><span>      </span><span style="font-style:italic;color:#5c6773;">// Send on the full todo state
</span><span>      </span><span style="color:#ffd580;">onTodoUpdate</span><span>(msg</span><span style="color:#f29e74;">.</span><span>todo)</span><span style="color:#ccc9c2cc;">;
</span><span>      todo </span><span style="color:#f29e74;">= </span><span>msg</span><span style="color:#f29e74;">.</span><span>todo</span><span style="color:#ccc9c2cc;">;
</span><span>      </span><span style="color:#ffa759;">break</span><span style="color:#ccc9c2cc;">;
</span><span>    }
</span><span>  }
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Now, we're almost done with the websocket, we need to integrate it a tiny bit nicer with react and react hooks.</p>
<p>Firstly, using the <code>useEffect</code> hook, we'll expose the <code>todo</code> state to a component which will rerender on object updates. You can provide a function starting with the keyword <code>use</code> to have it part of of the react render lifecycle.</p>
<p>We'll bind a call back to update a variable <code>todo</code> handled with <code>useState</code> when there are changes, and then return that variable state from the function to use in another component.</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">export const </span><span style="color:#ffd580;">useWebsocket </span><span style="color:#f29e74;">= </span><span>() </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  </span><span style="font-style:italic;color:#5c6773;">// Keep our local state of the todo app to trigger a render on change
</span><span>  </span><span style="color:#ffa759;">let </span><span>[todo</span><span style="color:#ccc9c2cc;">, </span><span>updateTodo] </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">useState</span><span>&lt;</span><span style="color:#73d0ff;">Todo</span><span>&gt;()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="color:#ffd580;">useEffect</span><span>(() </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Update our app state when changes are received
</span><span>    </span><span style="color:#ffd580;">setupWebsocket</span><span>((</span><span style="color:#ffcc66;">msg</span><span>) </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>      </span><span style="color:#ffd580;">updateTodo</span><span>(msg)</span><span style="color:#ccc9c2cc;">;
</span><span>    })</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// If the destructor runs, clean up the websocket
</span><span>    </span><span style="color:#ffa759;">return </span><span>() </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>      </span><span style="color:#ffa759;">if </span><span>(websocket) {
</span><span>        websocket</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">close</span><span>(</span><span style="color:#ffcc66;">1000</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>      }
</span><span>    }</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// The empty `[]` dependency list makes this `useEffect` callback execute only once on construction
</span><span>  }</span><span style="color:#ccc9c2cc;">, </span><span>[])</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="color:#ffa759;">return </span><span>todo</span><span style="color:#ccc9c2cc;">;
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Another way of looking at it is this function is purely glue code to make it easy to integrate with react.</p>
<p>Lastly, we'll cheat again with our global variables and have a <code>sendAction</code> method which will, if the websocket is up and running, send a <code>TodoAction</code> to the backend:</p>
<pre data-lang="typescript" style="background-color:#212733;color:#ccc9c2;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#ffa759;">export const </span><span style="color:#ffd580;">sendAction </span><span style="color:#f29e74;">= </span><span>(</span><span style="color:#ffcc66;">action</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TodoAction</span><span>)</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">void </span><span style="color:#ffa759;">=&gt; </span><span>{
</span><span>  </span><span style="color:#ffa759;">if </span><span>(websocket) {
</span><span>    websocket</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">send</span><span>(</span><span style="font-style:italic;color:#f29e74;">JSON</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">stringify</span><span>(action))</span><span style="color:#ccc9c2cc;">;
</span><span>  }
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h3 id="react-components">React Components</h3>
<p>We now have our general shape of our todo app, and have our websocket connection abstracted away nicely it's time to build up components.</p>
<p>We'll start with the main <code>App</code> component. This will be our root component, and will be responsible for building other components based upon the state. The <code>App</code> component is a perfect candidate to use our <code>useWebsocket</code> hook we have defined.</p>
<p>We'll add in a small &quot;loading&quot; indicator if the <code>todo</code> state is undefined, otherwise we'll pass on our <code>todo</code> state to a component:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#ffa759;">function </span><span style="color:#ffd580;">App</span><span>() {
</span><span>  </span><span style="color:#ffa759;">const </span><span>todo </span><span style="color:#f29e74;">= </span><span style="color:#ffd580;">useWebsocket</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>  </span><span style="color:#ffa759;">return </span><span>(
</span><span>    </span><span style="color:#f29e74;">&lt;</span><span>div className</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;container grid-lg&quot;</span><span style="color:#f29e74;">&gt;
</span><span>      </span><span style="color:#f29e74;">&lt;</span><span>div className</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;columns&quot;</span><span style="color:#f29e74;">&gt;
</span><span>        </span><span style="color:#f29e74;">&lt;</span><span>div className</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;column col-lg-12 todo-title&quot;</span><span style="color:#f29e74;">&gt;
</span><span>          &lt;</span><span style="color:#73d0ff;">h1</span><span>&gt;Todo App Example</span><span style="color:#f29e74;">&lt;/</span><span>h1</span><span style="color:#f29e74;">&gt;
</span><span>        </span><span style="color:#f29e74;">&lt;/</span><span>div</span><span style="color:#f29e74;">&gt;
</span><span>      </span><span style="color:#f29e74;">&lt;/</span><span>div</span><span style="color:#f29e74;">&gt;
</span><span>      {</span><span style="color:#ffcc66;">todo</span><span> === </span><span style="color:#ffcc66;">undefined</span><span> &amp;&amp; &lt;</span><span style="color:#ffcc66;">div className</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;loading loading-lg&quot;</span><span style="color:#f29e74;">&gt;</span><span>&lt;/</span><span style="color:#73d0ff;">div</span><span>&gt;}
</span><span>      {</span><span style="color:#ffcc66;">todo</span><span> &amp;&amp; &lt;</span><span style="color:#ffcc66;">TodoComponent todo</span><span style="color:#f29e74;">=</span><span>{todo} </span><span style="color:#f29e74;">/&gt;</span><span>}
</span><span>    </span><span style="color:#f29e74;">&lt;/</span><span>div</span><span style="color:#f29e74;">&gt;
</span><span>  )</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<h4 id="todo-component">Todo Component</h4>
<p>Our <code>TodoComponent</code> is responsible for some of the more &quot;global&quot; actions of our state, such as adding a new todo, changing the todo list name and clearing out completed todos.</p>
<p>Let's start with a standard functional component that takes a <code>todo</code> property as input:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#ffa759;">function </span><span style="color:#ffd580;">TodoComponent</span><span>({ </span><span style="color:#ffcc66;">todo </span><span>}</span><span style="color:#f29e74;">: </span><span>{ todo</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">Todo </span><span>}) {
</span><span>  </span><span style="color:#ffa759;">return </span><span>&lt;&gt;&lt;/&gt;</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>Now, let's build in the <code>todo.name</code> property. If we want users to be able to edit it, it should live in an input field:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>input value</span><span style="color:#f29e74;">=</span><span>{todo.name} </span><span style="color:#f29e74;">/&gt;
</span></code></pre>
<p>This will ensure the value is reflected, and since our <code>todo</code> object is &quot;hooked&quot; in to react, it will update when it changes.</p>
<p>The next step is to use an <code>onChange</code> callback to the input to send actions to the backed on change. We want to fire the <code>ChangeName</code> action, and so we can use the <code>sendAction</code> function from the websocket module to trigger this change.</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>input
</span><span>  value</span><span style="color:#f29e74;">=</span><span>{todo.name}
</span><span>  onChange</span><span style="color:#f29e74;">=</span><span>{(ev) =&gt; {
</span><span>    </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>      type: </span><span style="color:#bae67e;">&quot;ChangeName&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      name: </span><span style="color:#ffcc66;">ev</span><span>.</span><span style="color:#ffcc66;">currentTarget</span><span>.</span><span style="color:#ffcc66;">value</span><span style="color:#ccc9c2cc;">,
</span><span>    });
</span><span>  }}
</span><span style="color:#f29e74;">/&gt;
</span></code></pre>
<p>With that in place, we have the bare minimum implemented to see state changes. Now would be a great time, if you have been following along, to fire up your IDE and see what happens when you type in that input field (make sure the backend is running!).</p>
<p>Now, for each <code>TodoRow</code> we'll create a <code>TodoRowComponent</code>, which will be responsible for the state of that given row:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span>{
</span><span>  </span><span style="font-style:italic;color:#5ccfe6;">Object</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">entries</span><span>(todo</span><span style="color:#f29e74;">.</span><span>todos)</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">map</span><span>(([</span><span style="color:#ffcc66;">index</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">row</span><span>]) </span><span style="color:#ffa759;">=&gt; </span><span>(
</span><span>    </span><span style="color:#f29e74;">&lt;</span><span>TodoRowComponent key</span><span style="color:#f29e74;">=</span><span>{index} row</span><span style="color:#f29e74;">=</span><span>{row} index</span><span style="color:#f29e74;">=</span><span>{+index} </span><span style="color:#f29e74;">/&gt;
</span><span>  ))</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<p>And underneath our the list, we will have two buttons.</p>
<p>One that only displays if there are todos that are completed:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="font-style:italic;color:#5ccfe6;">Object</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">entries</span><span>(todo</span><span style="color:#f29e74;">.</span><span>todos)</span><span style="color:#f29e74;">.</span><span style="color:#ffd580;">some</span><span>(([</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">val</span><span>]) </span><span style="color:#ffa759;">=&gt; </span><span>val</span><span style="color:#f29e74;">.</span><span>completed) </span><span style="color:#f29e74;">&amp;&amp; </span><span>(
</span><span>  </span><span style="color:#f29e74;">&lt;</span><span>button
</span><span>    className</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;btn&quot;
</span><span>    onClick</span><span style="color:#f29e74;">=</span><span>{() =&gt; {
</span><span>      </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>        type: </span><span style="color:#bae67e;">&quot;RemoveCompleted&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      });
</span><span>    }}
</span><span>  </span><span style="color:#f29e74;">&gt;
</span><span>    Remove Completed
</span><span>  </span><span style="color:#f29e74;">&lt;/</span><span>button</span><span style="color:#f29e74;">&gt;
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>And one that adds an extra item to the list:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>button
</span><span>  onClick</span><span style="color:#f29e74;">=</span><span>{() =&gt; {
</span><span>    const entries </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Object</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">entries</span><span>(todo</span><span style="color:#f29e74;">.</span><span>todos);
</span><span>    </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>      type: </span><span style="color:#bae67e;">&quot;Add&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      row: {
</span><span>        name: </span><span style="color:#bae67e;">&quot;&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        completed: </span><span style="color:#ffcc66;">false</span><span style="color:#ccc9c2cc;">,
</span><span>      }</span><span style="color:#ccc9c2cc;">,
</span><span>    });
</span><span>  }}
</span><span style="color:#f29e74;">&gt;
</span><span>  Add Todo
</span><span style="color:#f29e74;">&lt;/</span><span>button</span><span style="color:#f29e74;">&gt;
</span></code></pre>
<h4 id="todorowcomponent">TodoRowComponent</h4>
<p>The TodoRowComponent will take a <code>TodoRow</code> and the <code>index</code> of that row, and display actions for the items in our todo list:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#ffa759;">function </span><span style="color:#ffd580;">TodoRowComponent</span><span>({ </span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">index </span><span>}</span><span style="color:#f29e74;">: </span><span>{ row</span><span style="color:#f29e74;">: </span><span style="color:#73d0ff;">TodoRow</span><span style="color:#ccc9c2cc;">; </span><span>index</span><span style="color:#f29e74;">: </span><span style="font-style:italic;color:#5ccfe6;">number </span><span>}) {
</span><span>    </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>We can add in a check box to mark things completed or not:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>input
</span><span>  type</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;checkbox&quot;
</span><span>  checked</span><span style="color:#f29e74;">=</span><span>{row.completed}
</span><span>  onChange</span><span style="color:#f29e74;">=</span><span>{() =&gt; {
</span><span>    </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>      type: </span><span style="color:#bae67e;">&quot;Update&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      row: {
</span><span>        </span><span style="color:#f29e74;">...</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">,
</span><span>        completed: !</span><span style="color:#ffcc66;">row</span><span>.</span><span style="color:#ffcc66;">completed</span><span style="color:#ccc9c2cc;">,
</span><span>        </span><span style="color:#ffcc66;">index</span><span style="color:#ccc9c2cc;">,
</span><span>      }</span><span style="color:#ccc9c2cc;">,
</span><span>    });
</span><span>  }}
</span><span style="color:#f29e74;">/&gt;
</span></code></pre>
<p>And an input for the name of the specific todo list:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>input
</span><span>  value</span><span style="color:#f29e74;">=</span><span>{row.name}
</span><span>  type</span><span style="color:#f29e74;">=</span><span style="color:#bae67e;">&quot;text&quot;
</span><span>  onChange</span><span style="color:#f29e74;">=</span><span>{(ev) =&gt;
</span><span>    </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>      type: </span><span style="color:#bae67e;">&quot;Update&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      row: {
</span><span>        </span><span style="color:#f29e74;">...</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">,
</span><span>        name: </span><span style="color:#ffcc66;">ev</span><span>.</span><span style="color:#ffcc66;">currentTarget</span><span>.</span><span style="color:#ffcc66;">value</span><span style="color:#ccc9c2cc;">,
</span><span>        </span><span style="color:#ffcc66;">index</span><span style="color:#ccc9c2cc;">,
</span><span>      }</span><span style="color:#ccc9c2cc;">,
</span><span>    })
</span><span>  }
</span><span style="color:#f29e74;">/&gt;
</span></code></pre>
<p>And a button to remove that row:</p>
<pre data-lang="js" style="background-color:#212733;color:#ccc9c2;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#f29e74;">&lt;</span><span>button
</span><span>  onClick</span><span style="color:#f29e74;">=</span><span>{() =&gt;
</span><span>    </span><span style="color:#ffd580;">sendAction</span><span>({
</span><span>      type: </span><span style="color:#bae67e;">&quot;Remove&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      </span><span style="color:#ffcc66;">index</span><span style="color:#ccc9c2cc;">,
</span><span>    })
</span><span>  }
</span><span style="color:#f29e74;">/&gt;
</span></code></pre>
<h2 id="running-and-debugging">Running and Debugging</h2>
<p>Ok, we now have a frontend wired up to a backend, with a websocket used for state updates. Let's change a few values around and see what is going across the &quot;wire&quot;.</p>
<p>The easiest way to do this, is via your browser's network tab, looking for the request to <code>ws://localhost:3000/ws</code>. In chrome, the tab you're looking for is <code>Messages</code>, and in firefox it's <code>Response</code>.</p>
<p>You can also use a tool like <a href="https://github.com/vi/websocat"><code>websocat</code></a> to view the messages in a terminal.</p>
<p>Running this up, you'll see the initial message come through when subscribed:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{ </span><span style="color:#bae67e;">&quot;type&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Full&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;todo&quot;</span><span style="color:#ccc9c2cc;">: </span><span>{ </span><span style="color:#bae67e;">&quot;name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;todos&quot;</span><span style="color:#ccc9c2cc;">: </span><span>[] } }
</span></code></pre>
<p>Then, making changes you will see the updates feed in. For instance if you click the <code>Add Todo</code> button, you'll see an outbound action:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{ </span><span style="color:#bae67e;">&quot;type&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Add&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;row&quot;</span><span style="color:#ccc9c2cc;">: </span><span>{ </span><span style="color:#bae67e;">&quot;name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;completed&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">false </span><span>} }
</span></code></pre>
<p>Followed by a patch update from the server:</p>
<pre data-lang="json" style="background-color:#212733;color:#ccc9c2;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  </span><span style="color:#bae67e;">&quot;type&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;Patch&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>  </span><span style="color:#bae67e;">&quot;ops&quot;</span><span style="color:#ccc9c2cc;">: </span><span>[
</span><span>    {
</span><span>      </span><span style="color:#bae67e;">&quot;op&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;add&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      </span><span style="color:#bae67e;">&quot;path&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;/todos/0&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>      </span><span style="color:#bae67e;">&quot;value&quot;</span><span style="color:#ccc9c2cc;">: </span><span>{ </span><span style="color:#bae67e;">&quot;completed&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">false</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;name&quot;</span><span style="color:#ccc9c2cc;">: </span><span style="color:#bae67e;">&quot;&quot; </span><span>}
</span><span>    }
</span><span>  ]
</span><span>}
</span></code></pre>
<p>Go ahead and try out other updates to see what patches are generated and get a feel for the JSON patch format.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Starting from the backend and then building out the frontend, we've used Websockets and JSON Patch to provide a platform of shared state updates.</p>
<p>Using existing standards and combining them together makes for a powerful and solid foundation. With rust, we get some great concurrency primitives that we can rely on to ensure our logic is correct.</p>
<p>We've demonstrated here that, we can provide a powerful framework, abstracting away our transport and state update logic, with room to grow.</p>
<p>The code for this article is available in a <a href="https://github.com/cetra3/websocket_jsonpatch/">source repository here</a>, so please feel free to tweak.</p>

  </section>
</article>


    </div>
</body>

</html>