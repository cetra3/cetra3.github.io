<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Detection with Actix Web</title>
    <meta name="description" content="Using MTCNN with Actix Web" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}hr{box-sizing:content-box;height:0;overflow:visible;}a{background-color:rgba(0,0,0,0);-webkit-text-decoration-skip:objects;}a:active,a:hover{outline-width:0}address{font-style:normal}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:"SF Mono","Segoe UI Mono","Roboto Mono",Menlo,Courier,monospace;font-size:1em;}dfn{font-style:italic}small{font-size:80%;font-weight:400;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;margin:0;}button,input{overflow:visible}button,select{text-transform:none}button,html [type=button],[type=reset],[type=submit]{-webkit-appearance:button;}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}fieldset{border:0;margin:0;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{display:inline-block;vertical-align:baseline;}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0;}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px;}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details,menu{display:block}summary{display:list-item;outline:none}canvas{display:inline-block}template{display:none}[hidden]{display:none}*,*::before,*::after{box-sizing:inherit}html{box-sizing:border-box;font-size:20px;line-height:1.5;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{background:#303742;color:#fff;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;font-size:.8rem;overflow-x:hidden;text-rendering:optimizeLegibility}a{color:#73c6ec;outline:none;text-decoration:none}a:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}a:focus,a:hover,a:active,a.active{color:#46b4e6;text-decoration:underline}a:visited{color:#a0d8f2}h1,h2,h3,h4,h5,h6{color:inherit;font-weight:700;line-height:1.2;margin-bottom:.5rem;margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{font-weight:700}h1,.h1{font-size:2rem}h2,.h2{font-size:1.6rem}h3,.h3{font-size:1.4rem}h4,.h4{font-size:1.2rem}h5,.h5{font-size:1rem}h6,.h6{font-size:.8rem}p{margin:0 0 1.2rem}a,ins,u{text-decoration-skip:ink edges}abbr[title]{border-bottom:.05rem dotted;cursor:help;text-decoration:none}kbd{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#303742;color:#fff;font-size:.7rem}mark{background:#ffe9b3;color:#fff;border-bottom:.05rem solid #ffd367;border-radius:.1rem;padding:.05rem .1rem 0}blockquote{border-left:.1rem solid #dadee4;margin-left:0;padding:.4rem .8rem}blockquote p:last-child{margin-bottom:0}ul,ol{margin:.8rem 0 .8rem .8rem;padding:0}ul ul,ul ol,ol ul,ol ol{margin:.8rem 0 .8rem .8rem}ul li,ol li{margin-top:.4rem}ul{list-style:disc inside}ul ul{list-style-type:circle}ol{list-style:decimal inside}ol ol{list-style-type:lower-alpha}dl dt{font-weight:bold}dl dd{margin:.4rem 0 .8rem 0}.btn{appearance:none;background:#fff;border:.05rem solid #73c6ec;border-radius:.1rem;color:#73c6ec;cursor:pointer;display:inline-block;font-size:.8rem;height:2.5rem;line-height:1.2rem;outline:none;padding:.6rem .4rem;text-align:center;text-decoration:none;transition:background .2s,border .2s,box-shadow .2s,color .2s;user-select:none;vertical-align:middle;white-space:nowrap}.btn:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}.btn:focus,.btn:hover{background:#fff;border-color:#66c1ea;text-decoration:none}.btn:active,.btn.active{background:#66c1ea;border-color:#4fb7e7;color:#fff;text-decoration:none}.btn:active.loading::after,.btn.active.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn[disabled],.btn:disabled,.btn.disabled{cursor:default;opacity:.5;pointer-events:none}.btn.btn-primary{background:#73c6ec;border-color:#66c1ea;color:#fff}.btn.btn-primary:focus,.btn.btn-primary:hover{background:#5dbde9;border-color:#4fb7e7;color:#fff}.btn.btn-primary:active,.btn.btn-primary.active{background:#54b9e8;border-color:#46b4e6;color:#fff}.btn.btn-primary.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-success{background:#32b643;border-color:#2faa3f;color:#fff}.btn.btn-success:focus{box-shadow:0 0 0 .1rem rgba(50,182,67,.2)}.btn.btn-success:focus,.btn.btn-success:hover{background:#30ae40;border-color:#2da23c;color:#fff}.btn.btn-success:active,.btn.btn-success.active{background:#2a9a39;border-color:#278e34;color:#fff}.btn.btn-success.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-error{background:#e85600;border-color:#d95000;color:#fff}.btn.btn-error:focus{box-shadow:0 0 0 .1rem rgba(232,86,0,.2)}.btn.btn-error:focus,.btn.btn-error:hover{background:#de5200;border-color:#cf4d00;color:#fff}.btn.btn-error:active,.btn.btn-error.active{background:#c44900;border-color:#b54300;color:#fff}.btn.btn-error.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-link{background:rgba(0,0,0,0);border-color:rgba(0,0,0,0);color:#73c6ec}.btn.btn-link:focus,.btn.btn-link:hover,.btn.btn-link:active,.btn.btn-link.active{color:#46b4e6}.btn.btn-sm{font-size:.7rem;height:1.4rem;padding:.05rem .3rem}.btn.btn-lg{font-size:.9rem;height:2rem;padding:.35rem .6rem}.btn.btn-block{display:block;width:100%}.btn.btn-action{width:2.5rem;padding-left:0;padding-right:0}.btn.btn-action.btn-sm{width:1.4rem}.btn.btn-action.btn-lg{width:2rem}.btn.btn-clear{background:rgba(0,0,0,0);border:0;color:currentColor;height:1rem;line-height:.8rem;margin-left:.2rem;margin-right:-2px;opacity:1;padding:.1rem;text-decoration:none;width:1rem}.btn.btn-clear:focus,.btn.btn-clear:hover{background:rgba(48,55,66,.5);opacity:.95}.btn.btn-clear::before{content:"✕"}.btn-group{display:inline-flex;flex-wrap:wrap}.btn-group .btn{flex:1 0 auto}.btn-group .btn:first-child:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group .btn:not(:first-child):not(:last-child){border-radius:0;margin-left:-.05rem}.btn-group .btn:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-.05rem}.btn-group .btn:focus,.btn-group .btn:hover,.btn-group .btn:active,.btn-group .btn.active{z-index:1}.btn-group.btn-group-block{display:flex}.btn-group.btn-group-block .btn{flex:1 0 0}.label{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#39414e;color:#e6e6e6;display:inline-block}.label.label-rounded{border-radius:5rem;padding-left:.4rem;padding-right:.4rem}.label.label-primary{background:#0b3e55;color:#fff}.label.label-secondary{background:#fff;color:#73c6ec}.label.label-success{background:#32b643;color:#fff}.label.label-warning{background:#ffb700;color:#fff}.label.label-error{background:#e85600;color:#fff}p code{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#0f4e6b;color:#fff;font-size:85%}.code{border-radius:.1rem;color:#fff;position:relative}.code::before{color:#bcc3ce;content:attr(data-lang);font-size:.7rem;position:absolute;right:.4rem;top:.1rem}.code code{background:#303742;color:inherit;display:block;line-height:1.5;overflow-x:auto;padding:1rem;width:100%}.container{margin-left:auto;margin-right:auto;padding-left:.4rem;padding-right:.4rem;width:100%}.container.grid-xl{max-width:1296px}.container.grid-lg{max-width:976px}.container.grid-md{max-width:856px}.container.grid-sm{max-width:616px}.container.grid-xs{max-width:496px}.show-xs,.show-sm,.show-md,.show-lg,.show-xl{display:none !important}.columns{display:flex;flex-wrap:wrap;margin-left:-.4rem;margin-right:-.4rem}.columns.col-gapless{margin-left:0;margin-right:0}.columns.col-gapless>.column{padding-left:0;padding-right:0}.columns.col-oneline{flex-wrap:nowrap;overflow-x:auto}.column{flex:1;max-width:100%;padding-left:.4rem;padding-right:.4rem}.column.col-12,.column.col-11,.column.col-10,.column.col-9,.column.col-8,.column.col-7,.column.col-6,.column.col-5,.column.col-4,.column.col-3,.column.col-2,.column.col-1{flex:none}.col-12{width:100%}.col-11{width:91.66666667%}.col-10{width:83.33333333%}.col-9{width:75%}.col-8{width:66.66666667%}.col-7{width:58.33333333%}.col-6{width:50%}.col-5{width:41.66666667%}.col-4{width:33.33333333%}.col-3{width:25%}.col-2{width:16.66666667%}.col-1{width:8.33333333%}.col-auto{flex:0 0 auto;max-width:none;width:auto}.col-mx-auto{margin-left:auto;margin-right:auto}.col-ml-auto{margin-left:auto}.col-mr-auto{margin-right:auto}@media (max-width: 1280px){.col-xl-12,.col-xl-11,.col-xl-10,.col-xl-9,.col-xl-8,.col-xl-7,.col-xl-6,.col-xl-5,.col-xl-4,.col-xl-3,.col-xl-2,.col-xl-1{flex:none}.col-xl-12{width:100%}.col-xl-11{width:91.66666667%}.col-xl-10{width:83.33333333%}.col-xl-9{width:75%}.col-xl-8{width:66.66666667%}.col-xl-7{width:58.33333333%}.col-xl-6{width:50%}.col-xl-5{width:41.66666667%}.col-xl-4{width:33.33333333%}.col-xl-3{width:25%}.col-xl-2{width:16.66666667%}.col-xl-1{width:8.33333333%}.hide-xl{display:none !important}.show-xl{display:block !important}}@media (max-width: 960px){.col-lg-12,.col-lg-11,.col-lg-10,.col-lg-9,.col-lg-8,.col-lg-7,.col-lg-6,.col-lg-5,.col-lg-4,.col-lg-3,.col-lg-2,.col-lg-1{flex:none}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.hide-lg{display:none !important}.show-lg{display:block !important}}@media (max-width: 840px){.col-md-12,.col-md-11,.col-md-10,.col-md-9,.col-md-8,.col-md-7,.col-md-6,.col-md-5,.col-md-4,.col-md-3,.col-md-2,.col-md-1{flex:none}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.hide-md{display:none !important}.show-md{display:block !important}}@media (max-width: 600px){.col-sm-12,.col-sm-11,.col-sm-10,.col-sm-9,.col-sm-8,.col-sm-7,.col-sm-6,.col-sm-5,.col-sm-4,.col-sm-3,.col-sm-2,.col-sm-1{flex:none}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.hide-sm{display:none !important}.show-sm{display:block !important}}@media (max-width: 480px){.col-xs-12,.col-xs-11,.col-xs-10,.col-xs-9,.col-xs-8,.col-xs-7,.col-xs-6,.col-xs-5,.col-xs-4,.col-xs-3,.col-xs-2,.col-xs-1{flex:none}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.hide-xs{display:none !important}.show-xs{display:block !important}}.navbar{align-items:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin-left:auto;margin-right:auto;max-width:960px}.navbar .navbar-section{align-items:center;display:flex;flex:1 0 0}.navbar .navbar-section:not(:first-child):last-child{justify-content:flex-end}.navbar .navbar-center{align-items:center;display:flex;flex:0 0 auto}.navbar .navbar-brand{font-size:.9rem;text-decoration:none}pre{padding:.5rem .5rem;border-radius:.3rem;overflow-y:auto}.post header{border-radius:.3rem;padding:.5rem;margin-bottom:.5rem}.post header h1{margin-bottom:0}.post section{padding:.5rem;background-color:#2a3039;border-radius:.3rem}.post img{width:100%}.post .utterances{max-width:none !important}.card{margin-bottom:.5rem}.main-header{margin-bottom:.5rem;background-color:#272d36;box-shadow:0 20rem 20rem 20rem rgba(115,198,236,.2)}.card{background:#2a3039;border-radius:.3rem;display:flex;flex-direction:column}.card .card-header,.card .card-body,.card .card-footer{padding:.8rem;padding-bottom:0}.card .card-header:last-child,.card .card-body:last-child,.card .card-footer:last-child{padding-bottom:.8rem}.card .card-body{flex:1 1 auto}.card .card-image{padding-top:.8rem}.card .card-image:first-child{padding-top:0}.card .card-image:first-child img{border-top-left-radius:.1rem;border-top-right-radius:.1rem}.card .card-image:last-child img{border-bottom-left-radius:.1rem;border-bottom-right-radius:.1rem}</style>
</head>

<body>
    <header class="main-header">
        <div class="navbar">
        <section class="navbar-section">
            <img src="/favicon.svg" width="30" height="30"/>
            <a href="/" class="btn btn-link">Home</a>
            <a href="/blog/" class="btn btn-link">Blogs</a>
            <a href="/rss.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
        </div>
    </header>
    <div class="container grid-lg">
        
<article class="post">
  <header>
  <h1>Face Detection with Actix Web </h1>
  <em>Using MTCNN with Actix Web</em>
  <br />
  
  <small class="label label-primary">rust</small> <small class="label">2019-04-11</small>
  
  </header>
  <section>
    <p>Last article I wrote about how to <a href="https://cetra3.github.io/blog/face-detection-with-tensorflow-rust/">use tensorflow with rust</a>.  This time we're going to take what we've built on, and serve it as an HTTP API call.  As <a href="https://github.com/actix/actix-web">Actix Web</a> is nearing its inevitable <a href="https://github.com/actix/actix-web/issues/722">1.0 release</a>, I thought it would be a great time to build something with it.</p>
<p>This article assumes you have some knowledge about <a href="https://github.com/rust-lang-nursery/futures-rs">Futures</a> and how they work. I will do my best to explain in simpler terms, but understanding the futures ecosystem would be quite handy to help work through this article. For this, I suggest you start with <a href="https://tokio.rs/">tokio</a>.</p>
<p><em>(Some people have suggested waiting for async/await and friends to land before diving into Futures.  I think you should get your hands dirty now: async programming will always be challenging and the changes being introduced only affect ergonomics, not fundamentals)</em></p>
<p>Once again for the impatient, you can find the reference code here on the <code>actix-web</code> branch: </p>
<p><a href="https://github.com/cetra3/mtcnn/tree/actix-web">https://github.com/cetra3/mtcnn/tree/actix-web</a></p>
<h2 id="api-shape">API Shape</h2>
<p>The API shape here is rather simple.  We want to emulate what we've done on the command line: Submit a picture, have a picture returned.  To make things interesting, we'll provide a way to return the bounding boxes as a JSON array too.</p>
<p>For submitting binary data via HTTP, there are a few options off the top of my head:</p>
<ul>
<li>Simply submit the raw data as it stands</li>
<li>Use <code>multipart/form-data</code></li>
<li>Encode it as a JSON submission</li>
</ul>
<p>I think the easiest would be just the raw data so let's do that!  Multipart could possibly also work, but what about the case when you have to handle multiple images?  JSON Submission seems a bit wasteful, as you would inevitably have to convert binary data using base64 or similar.</p>
<p>So our API looks like this:</p>
<ul>
<li>Submit POST request as a raw file submission</li>
<li>Run a session against mtcnn to extract faces</li>
<li>Either return Bounding Boxes as JSON, or an Image Overlay as a JPEG like the command line example</li>
</ul>
<h2 id="mtcnn-as-a-struct">MTCNN as a struct</h2>
<p>In our last blog we just simply used the <code>main</code> function to perform everything, but it's not going to fly with actix until we do a bit of a refactor.  We want to encapsulate the mtcnn behaviour as a struct, something that can be passed around and moved.  The end goal is to use it in the application state.</p>
<h3 id="struct-shape">Struct Shape</h3>
<p>Let's make our struct include everything we need:</p>
<ul>
<li>The <code>Graph</code></li>
<li>The <code>Session</code></li>
<li>Some of the <code>Tensor</code> input params that don't change from request to request.</li>
</ul>
<p>We'll start by creating a new file <code>mtcnn.rs</code> and adding in the struct definition.</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>tensorflow</span><span style="color:#f29e74;">::</span><span>{Graph</span><span style="color:#ccc9c2cc;">,</span><span> Session</span><span style="color:#ccc9c2cc;">,</span><span> Tensor}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">Mtcnn </span><span>{
</span><span>    graph</span><span style="color:#ccc9c2cc;">:</span><span> Graph,
</span><span>    session</span><span style="color:#ccc9c2cc;">:</span><span> Session,
</span><span>    min_size</span><span style="color:#ccc9c2cc;">: </span><span>Tensor&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>    thresholds</span><span style="color:#ccc9c2cc;">: </span><span>Tensor&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>    factor</span><span style="color:#ccc9c2cc;">: </span><span>Tensor&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;
</span><span>}
</span></code></pre>
<p>Ok, now we're just going to plop in the initiation stuff in a <code>new()</code> method.  As the creation of some of these values is not infallible, we'll return a <code>Result</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">new</span><span>() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, </span><span style="font-style:italic;color:#5ccfe6;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> model </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">include_bytes!</span><span>(</span><span style="color:#bae67e;">&quot;mtcnn.pb&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let mut</span><span> graph </span><span style="color:#f29e74;">= </span><span>Graph</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>    graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">import_graph_def</span><span>(</span><span style="color:#f29e74;">&amp;*</span><span>model</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>ImportGraphDefOptions</span><span style="color:#f29e74;">::</span><span>new())</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> session </span><span style="color:#f29e74;">= </span><span>Session</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span>SessionOptions</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>graph)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">let</span><span> min_size </span><span style="color:#f29e74;">= </span><span>Tensor</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span>[])</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">with_values</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>[</span><span style="color:#ffcc66;">40</span><span style="color:#ffa759;">f32</span><span>])</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">let</span><span> thresholds </span><span style="color:#f29e74;">= </span><span>Tensor</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span>[</span><span style="color:#ffcc66;">3</span><span>])</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">with_values</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>[</span><span style="color:#ffcc66;">0.6</span><span style="color:#ffa759;">f32</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0.7</span><span style="color:#ffa759;">f32</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0.7</span><span style="color:#ffa759;">f32</span><span>])</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">let</span><span> factor </span><span style="color:#f29e74;">= </span><span>Tensor</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span>[])</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">with_values</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>[</span><span style="color:#ffcc66;">0.709</span><span style="color:#ffa759;">f32</span><span>])</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>        graph</span><span style="color:#ccc9c2cc;">,
</span><span>        session</span><span style="color:#ccc9c2cc;">,
</span><span>        min_size</span><span style="color:#ccc9c2cc;">,
</span><span>        thresholds</span><span style="color:#ccc9c2cc;">,
</span><span>        factor
</span><span>    })
</span><span>
</span><span>}
</span></code></pre>
<h3 id="the-run-function">The Run Function</h3>
<p><em>(I'm going to race along here to get to the good parts, so if you get stuck or are unsure about what's going on, have a look at the <a href="https://cetra3.github.io/blog/face-detection-with-tensorflow-rust/">original article</a> for an explanation of what's happening here.)</em></p>
<p>We've added all the bits we need to run our session Let's create a method that does what we're asking the API to do: submit an image, return some bounding boxes:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>DynamicImage) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBoxes&gt;, Status&gt; {
</span><span>    </span><span style="color:#f29e74;">...
</span><span>}
</span></code></pre>
<p>Once again, we are returning a <code>Result</code> as the type, as there are some parts of the <code>run</code> that can fail.  We're going to use the <code>Status</code> type as that is normally the error type returned</p>
<p>Like our previous main function, we'll need to flatten the image input:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> input </span><span style="color:#f29e74;">= </span><span>{
</span><span>    </span><span style="color:#ffa759;">let mut</span><span> flattened</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#ffa759;">f32</span><span>&gt; </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">for </span><span>(_x</span><span style="color:#ccc9c2cc;">,</span><span> _y</span><span style="color:#ccc9c2cc;">,</span><span> rgb) </span><span style="color:#f29e74;">in</span><span> img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">pixels</span><span>() {
</span><span>        flattened</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(rgb[</span><span style="color:#ffcc66;">2</span><span>] </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">f32</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>        flattened</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(rgb[</span><span style="color:#ffcc66;">1</span><span>] </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">f32</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>        flattened</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(rgb[</span><span style="color:#ffcc66;">0</span><span>] </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">f32</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>    }
</span><span>
</span><span>    Tensor</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#f29e74;">&amp;</span><span>[img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">height</span><span>() </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">u64</span><span style="color:#ccc9c2cc;">,</span><span> img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">width</span><span>() </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">u64</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">3</span><span>])
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">with_values</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>flattened)</span><span style="color:#f29e74;">?
</span><span>}</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Then we'll feed in all the relevant inputs.  This is just the same as our previous <code>main</code> function, but we're going to just borrow values from <code>self</code> rather than create them for each run:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> args </span><span style="color:#f29e74;">= </span><span>SessionRunArgs</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_feed</span><span>(
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;min_size&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>min_size</span><span style="color:#ccc9c2cc;">,
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_feed</span><span>(
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;thresholds&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>thresholds</span><span style="color:#ccc9c2cc;">,
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_feed</span><span>(
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;factor&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
</span><span>    </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>factor</span><span style="color:#ccc9c2cc;">,
</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_feed</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;input&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>input)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Next, let's grab the outputs we want:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> bbox </span><span style="color:#f29e74;">=</span><span> args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request_fetch</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;box&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">let</span><span> prob </span><span style="color:#f29e74;">=</span><span> args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request_fetch</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>graph</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">operation_by_name_required</span><span>(</span><span style="color:#bae67e;">&quot;prob&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h3 id="running-the-session">Running The Session</h3>
<p>Now we have all our args set up, we can run the session:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>session</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> args)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Uh oh.  We're getting a compiler error here... </p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>error[</span><span style="color:#ffcc66;">E0596</span><span>]</span><span style="color:#ccc9c2cc;">:</span><span> cannot borrow `</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>session` </span><span style="color:#f29e74;">as</span><span> mutable</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">as</span><span> it is behind a `</span><span style="color:#f29e74;">&amp;</span><span>` reference
</span><span>  </span><span style="color:#f29e74;">-</span><span style="color:#ccc9c2cc;">-&gt;</span><span> src</span><span style="color:#f29e74;">/</span><span>mtcnn</span><span style="color:#f29e74;">.</span><span>rs</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffcc66;">68</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffcc66;">10
</span><span>   </span><span style="color:#f29e74;">|
</span><span style="color:#ffcc66;">36 </span><span style="color:#f29e74;">|     </span><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span>, </span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>DynamicImage) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;DynamicImage, </span><span style="font-style:italic;color:#5ccfe6;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>   </span><span style="color:#f29e74;">|                -----</span><span> help</span><span style="color:#ccc9c2cc;">:</span><span> consider changing this to be a mutable reference</span><span style="color:#ccc9c2cc;">:</span><span> `</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="font-style:italic;color:#5ccfe6;">self</span><span>`
</span><span style="color:#f29e74;">...
</span><span style="color:#ffcc66;">68 </span><span style="color:#f29e74;">|         &amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span>session</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> args)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>   |          ^^^^^^^^^^^^ `</span><span style="color:#ffcc66;">self</span><span>` is a `</span><span style="color:#f29e74;">&amp;</span><span>` </span><span style="color:#ffcc66;">reference</span><span style="color:#ccc9c2cc;">,</span><span> so the data it refers to cannot be borrowed as mutable
</span></code></pre>
<p>Turns out that the <code>Session::run()</code> function takes <code>&amp;mut self</code>.</p>
<p>What can we do to resolve this:</p>
<ul>
<li>Make our <code>run</code> function take <code>&amp;mut self</code> so we can mutate the field</li>
<li>Do some tricky interior mutability</li>
<li>Submit an <a href="https://github.com/tensorflow/rust/issues/192">issue on the tensorflow-rust crate</a> to see whether <code>Session</code> <em>really</em> needs to take <code>&amp;mut self</code>.</li>
</ul>
<p>We'll go with option 3!</p>
<p>Update your <code>Cargo.toml</code> to point to the git master, rather than the cargo version:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>tensorflow = { git = &quot;https://github.com/tensorflow/rust&quot;}
</span></code></pre>
<h3 id="getting-the-bounding-boxes">Getting the Bounding Boxes</h3>
<p>This has not changed at all since our <code>main</code> method.  We grab the bounding boxes, put them in our handy dandy <code>BBox</code> struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">//Our bounding box extents
</span><span style="color:#ffa759;">let</span><span> bbox_res</span><span style="color:#ccc9c2cc;">: </span><span>Tensor&lt;</span><span style="color:#ffa759;">f32</span><span>&gt; </span><span style="color:#f29e74;">=</span><span> args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch</span><span>(bbox)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">//Our facial probability
</span><span style="color:#ffa759;">let</span><span> prob_res</span><span style="color:#ccc9c2cc;">: </span><span>Tensor&lt;</span><span style="color:#ffa759;">f32</span><span>&gt; </span><span style="color:#f29e74;">=</span><span> args</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">fetch</span><span>(prob)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">//Let&#39;s store the results as a Vec&lt;BBox&gt;
</span><span style="color:#ffa759;">let mut</span><span> bboxes </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">let mut</span><span> i </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">let mut</span><span> j </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">//While we have responses, iterate through
</span><span style="color:#ffa759;">while</span><span> i </span><span style="color:#f29e74;">&lt;</span><span> bbox_res</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">len</span><span>() {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Add in the 4 floats from the `bbox_res` array.
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Notice the y1, x1, etc.. is ordered differently to our struct definition.
</span><span>    bboxes</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span>(BBox {
</span><span>        y1</span><span style="color:#ccc9c2cc;">:</span><span> bbox_res[i]</span><span style="color:#ccc9c2cc;">,
</span><span>        x1</span><span style="color:#ccc9c2cc;">:</span><span> bbox_res[i </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">1</span><span>]</span><span style="color:#ccc9c2cc;">,
</span><span>        y2</span><span style="color:#ccc9c2cc;">:</span><span> bbox_res[i </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">2</span><span>]</span><span style="color:#ccc9c2cc;">,
</span><span>        x2</span><span style="color:#ccc9c2cc;">:</span><span> bbox_res[i </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">3</span><span>]</span><span style="color:#ccc9c2cc;">,
</span><span>        prob</span><span style="color:#ccc9c2cc;">:</span><span> prob_res[j]</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5c6773;">// Add in the facial probability
</span><span>    })</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Step `i` ahead by 4.
</span><span>    i </span><span style="color:#f29e74;">+= </span><span style="color:#ffcc66;">4</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Step `i` ahead by 1.
</span><span>    j </span><span style="color:#f29e74;">+= </span><span style="color:#ffcc66;">1</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="color:#f28779;">debug!</span><span>(</span><span style="color:#bae67e;">&quot;BBox Length: {}, BBoxes:{:#?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span> bboxes</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">len</span><span>()</span><span style="color:#ccc9c2cc;">,</span><span> bboxes)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(bboxes)
</span></code></pre>
<p>And that's our <code>run</code> function finished.</p>
<h3 id="bbox-struct-as-json">BBox Struct as JSON</h3>
<p>We're gonna want to return a JSON representation of the BBox struct.  So let's add in <code>serde_derive</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>serde_derive</span><span style="color:#f29e74;">::</span><span>Serialize</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(Copy</span><span style="color:#ccc9c2cc;">,</span><span> Clone</span><span style="color:#ccc9c2cc;">,</span><span> Debug</span><span style="color:#ccc9c2cc;">,</span><span> Serialize)]
</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">BBox </span><span>{
</span><span>    </span><span style="color:#ffa759;">pub </span><span>x1</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>y1</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>x2</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>y2</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>prob</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>}
</span></code></pre>
<h3 id="drawing-the-output-image">Drawing the Output Image</h3>
<p>We'll create a function that will take a list of bounding boxes and an input image, returning the output image:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">overlay</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span>DynamicImage, </span><span style="color:#ffcc66;">bboxes</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> DynamicImage
</span></code></pre>
<p>This hasn't changed much either, but we are returning the image, rather than saving it to a file:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">//Let&#39;s clone the input image
</span><span style="color:#ffa759;">let mut</span><span> output_image </span><span style="color:#f29e74;">=</span><span> img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">//Iterate through all bounding boxes
</span><span style="color:#ffa759;">for</span><span> bbox </span><span style="color:#f29e74;">in</span><span> bboxes {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Create a `Rect` from the bounding box.
</span><span>    </span><span style="color:#ffa759;">let</span><span> rect </span><span style="color:#f29e74;">= </span><span>Rect</span><span style="color:#f29e74;">::</span><span>at(bbox</span><span style="color:#f29e74;">.</span><span>x1 </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">i32</span><span style="color:#ccc9c2cc;">,</span><span> bbox</span><span style="color:#f29e74;">.</span><span>y1 </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">i32</span><span>)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">of_size</span><span>((bbox</span><span style="color:#f29e74;">.</span><span>x2 </span><span style="color:#f29e74;">-</span><span> bbox</span><span style="color:#f29e74;">.</span><span>x1) </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">u32</span><span style="color:#ccc9c2cc;">, </span><span>(bbox</span><span style="color:#f29e74;">.</span><span>y2 </span><span style="color:#f29e74;">-</span><span> bbox</span><span style="color:#f29e74;">.</span><span>y1) </span><span style="color:#f29e74;">as </span><span style="color:#ffa759;">u32</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//Draw a green line around the bounding box
</span><span>    </span><span style="color:#f28779;">draw_hollow_rect_mut</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> output_image</span><span style="color:#ccc9c2cc;">,</span><span> rect</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">LINE_COLOUR</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span>output_image
</span></code></pre>
<p>Ok, we're pretty much done with our <code>Mtcnn</code> struct and functions! Could we break this down even further? Yeah definitely! But for now, I think this is all we need.  We've encapsulated the behaviour and created a nice to use couple of functions.</p>
<h2 id="our-new-main-function">Our New Main Function</h2>
<p>Ok, so we're no longer using it as a CLI, but as a self-hosted web app.  We're going to need to change the arguments our application takes since we no longer have input and output files.</p>
<p>I think the only argument we should be taking initially is the listen address, and even then we should use a sensible default. So let's use the help of <a href="https://github.com/TeXitoi/structopt">structopt</a> to make this pretty minimal boilerplate:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(StructOpt)]
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Opt </span><span>{
</span><span>    </span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">structopt</span><span>(
</span><span>        short </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;l&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        long </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;listen&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        help </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;Listen Address&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        default_value </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;127.0.0.1:8000&quot;
</span><span>    )]
</span><span>    listen</span><span style="color:#ccc9c2cc;">:</span><span> String,
</span><span>}
</span></code></pre>
<h3 id="logging-framework">Logging Framework</h3>
<p>Actix Web uses the <a href="https://github.com/rust-lang-nursery/log">log</a> crate to display errors and debug messages.</p>
<p>Let's move on from using <code>println!</code> and instead use log.  I like using <a href="https://github.com/seanmonstar/pretty-env-logger">pretty_env_logger</a> as it prints different levels as a different colour, and we can have timestamps which is useful.</p>
<p><code>pretty_env_logger</code> still uses environment vars.  Let's cheat and set our <code>RUST_LOG</code> var if none is provided then initiate our logger</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">//Set the `RUST_LOG` var if none is provided
</span><span style="color:#ffa759;">if </span><span>env</span><span style="color:#f29e74;">::</span><span>var(</span><span style="color:#bae67e;">&quot;RUST_LOG&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">is_err</span><span>() {
</span><span>    env</span><span style="color:#f29e74;">::</span><span>set_var(</span><span style="color:#bae67e;">&quot;RUST_LOG&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;mtcnn=DEBUG,actix_web=DEBUG&quot;</span><span>)</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#5c6773;">//Create a timestamped logger
</span><span>pretty_env_logger</span><span style="color:#f29e74;">::</span><span>init_timed()</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>This sets up <code>DEBUG</code> level logs for our app and actix web, but allows us to change the log levels via environment variables still.</p>
<h2 id="actix-and-state">Actix and State</h2>
<p>We have some state we need to pass to actix to use: our <code>Mtcnn</code> struct and the run method.  There are a number of ways you can give State to actix, but probably the easiest way is the <code>App::data</code> method.  As we are now entering a multithreaded world, we're going to have to think about what things are <code>Send</code> and <code>Sync</code>.</p>
<p>Ok, so how do we share something between threads? Well, as a first step I would look to <code>std::sync</code> to see what we need.  Since we know that mtcnn's <code>run</code> function does not need to mutate it, only requiring a reference to immutable <code>self</code>, we can probably wrap it in an <code>Arc</code>.  If we had to mutate it, then it would probably require a Mutex as well, but we can avoid this if we use the <code>master</code> branch of <code>tensorflow-rust</code> as above.</p>
<p>So let's create our Arc:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> mtcnn </span><span style="color:#f29e74;">= </span><span>Arc</span><span style="color:#f29e74;">::</span><span>new(Mtcnn</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#f29e74;">?</span><span>)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Now, to instantiate the server:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>HttpServer</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>    App</span><span style="color:#f29e74;">::</span><span>new()
</span><span>        </span><span style="font-style:italic;color:#5c6773;">//Add in our mtcnn struct, we clone the reference for each worker thread
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">data</span><span>(mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span>())
</span><span>        </span><span style="font-style:italic;color:#5c6773;">//Add in a logger to see the requests coming through
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wrap</span><span>(middleware</span><span style="color:#f29e74;">::</span><span>Logger</span><span style="color:#f29e74;">::</span><span>default())
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Add in some routes here
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">service</span><span>(
</span><span>            </span><span style="color:#f29e74;">...
</span><span>        )
</span><span>})
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>opt</span><span style="color:#f29e74;">.</span><span>listen)</span><span style="color:#f29e74;">? </span><span style="font-style:italic;color:#5c6773;">// Use the listener from the command arguments
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>()
</span></code></pre>
<p>Ok, let's step through what we're doing:</p>
<ul>
<li>We first build a <code>HttpServer</code></li>
<li>This takes a closure which should return an <code>App</code>.  This <code>App</code> is instantiated for each thread the http server is running</li>
<li>We add our <code>Arc&lt;Mtcnn&gt;</code> using the <code>data</code> method, and clone it for each thread listener.</li>
<li>We add a logger middleware.</li>
<li>We set up some routes with the <code>service</code> function</li>
<li>Then we bind to a listen address and run</li>
</ul>
<h2 id="handling-a-request">Handling a Request</h2>
<p>Actix Web is an Async framework and uses tokio.  Our function is Synchronous and takes some time to complete.</p>
<p>In other words, our request is blocking.  Can we mix and match sync and async? Absolutely, but it is a little more cumbersome as you'll see.</p>
<h3 id="function-signature-and-extractors">Function Signature and Extractors</h3>
<p>Actix 1.0 makes heavy use of Extractors, which is a way of providing functions of quite different shapes.  You basically specify what you want your web function to receive, and actix will wire it up for you.  Take care though:  This does mean that some things won't be discovered wrong until runtime.  A perfect example I had when I used the wrong type signature for the <code>web::Data</code> argument.</p>
<p>So what do we need to <em>extract</em> from our request? The bytes of the request body, and and also our <code>mtcnn</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">handle_request</span><span>(
</span><span>    </span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Data&lt;Arc&lt;Mtcnn&gt;&gt;,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = HttpResponse, Error = ActixError&gt; {
</span><span>
</span><span>    </span><span style="color:#f29e74;">...
</span><span>
</span><span>}
</span></code></pre>
<p>We will use this type signature for <code>mtcnn</code> a fair bit, so let's make a type alias for it:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">WebMtcnn </span><span style="color:#f29e74;">= </span><span>web</span><span style="color:#f29e74;">::</span><span>Data&lt;Arc&lt;Mtcnn&gt;&gt;</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<h2 id="getting-the-image-from-a-payload">Getting the Image from a Payload</h2>
<p>Ok, so we need a way of retrieving the image from a payload and returning a Future.  The <code>web::Payload</code> struct implements <a href="https://docs.rs/futures/0.1.26/futures/stream/trait.Stream.html">Stream</a> with <code>Item</code> set to <a href="https://docs.rs/bytes/0.4.12/bytes/struct.Bytes.html">Bytes</a>.</p>
<p>Well, we don't really care about the individual bytes we get from a stream, we want the whole lot to decode the image!  So let's convert the <code>Stream</code> into a <code>Future</code>, and merge all the individual bytes we'll be getting into one big bucket of bytes.  Sounds complicated, but luckily Stream has a method: <a href="https://docs.rs/futures/0.1.26/futures/stream/trait.Stream.html#method.concat2">concat2</a>. </p>
<p>This is a pretty powerful combinator which allows us to join the results of individual Stream polls into one if the item implements <a href="https://doc.rust-lang.org/nightly/core/iter/trait.Extend.html">Extend</a> (and some other traits) which <code>Bytes</code> happens to.</p>
<p>So this looks like:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#f29e74;">....</span><span>)
</span></code></pre>
<h3 id="image-decoding-and-web-block">Image Decoding and <code>web::block</code></h3>
<p>Ok, second thing we need to sort out, if we're going to be decoding an image, that is probably going to block the thread until it's done.  How long? Well if it's a huge image, it might take milliseconds!  So we want to ensure that we're not blocking the http workers while this is happening.  Luckily, actix web has a way of taking a blocking portion of code, and wrapping that as a future.</p>
<p>Enter <code>web::block</code>.  We'll do our decoding in a cpu pool, bridging sync and async together:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>bytes</span><span style="color:#f29e74;">| </span><span>{
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>        image</span><span style="color:#f29e74;">::</span><span>load_from_memory(</span><span style="color:#f29e74;">&amp;</span><span>bytes)
</span><span>    })
</span><span>})
</span></code></pre>
<p>Ok, that is pretty succint: we take a stream, convert it into a future and a bundle of bytes, then use <code>web::block</code> to decode the bytes into an image in a background thread and return the result.  the <code>load_from_memory</code> function already returns a Result, which means we can just use that as the return type.</p>
<h3 id="balancing-the-error-type">Balancing the Error Type</h3>
<p>So, our Item is converted to <code>Bytes</code> to <code>DynamicImage</code>, but we still haven't dealt with the error types yet and it won't compile.  What should our error type be?  Let's use <code>actix_web::Error</code> as <code>ActixError</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>actix_web</span><span style="color:#f29e74;">::</span><span>{Error </span><span style="color:#f29e74;">as</span><span> ActixError}
</span><span>
</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_image</span><span>(</span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = DynamicImage, Error = ActixError&gt; {
</span><span>    stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>bytes</span><span style="color:#f29e74;">| </span><span>{
</span><span>        web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>            image</span><span style="color:#f29e74;">::</span><span>load_from_memory(</span><span style="color:#f29e74;">&amp;</span><span>bytes)
</span><span>        })
</span><span>    })
</span><span>}
</span></code></pre>
<p>Ok, that is giving us few really gnarly errors when we try and compile it:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>error[E0271]: type mismatch resolving `&lt;impl futures::future::Future as futures::future::IntoFuture&gt;::Error == actix_http::error::PayloadError`
</span><span>  --&gt; src/main.rs:67:22
</span><span>   |
</span><span>67 |     stream.concat2().and_then(move |bytes| {
</span><span>   |                      ^^^^^^^^ expected enum `actix_threadpool::BlockingError`, found enum `actix_http::error::PayloadError`
</span><span>   |
</span><span>   = note: expected type `actix_threadpool::BlockingError&lt;image::image::ImageError&gt;`
</span><span>              found type `actix_http::error::PayloadError`
</span></code></pre>
<p>There's a couple more that aren't listed.</p>
<p>When you are combining streams, mapping them as futures, and otherwise trying to get some output from these combinators you are actually dealing with both the <code>Item</code> type, and the <code>Error</code> type.</p>
<p>The ergonomics of this are not as advanced as the <code>Result</code> type, where we can use the <code>?</code> operator to automatically adjust to the right error (if a conversion is available). When both <code>ops::Try</code> and <code>async/await</code> syntax stabilises, this might be a different story, but for now, we need to deal with error types.</p>
<p>What we have instead is the magic™️ <code>from_err()</code> method.  This is basically the same as the <code>?</code> operator but for futures.  We have two futures we're dealing with: our bundle of bytes from the stream, and the image from the blocking closure. We have 3 error types we're dealing with: the Payload error, the Image load from memory error, and the blocking error.</p>
<p>Let's start by putting <code>from_err()</code> on both of the futures:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_image</span><span>(</span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload)
</span><span>  </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = DynamicImage, Error = ActixError&gt; {
</span><span>    stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>bytes</span><span style="color:#f29e74;">| </span><span>{
</span><span>        web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>            image</span><span style="color:#f29e74;">::</span><span>load_from_memory(</span><span style="color:#f29e74;">&amp;</span><span>bytes)
</span><span>        })</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>    })
</span><span>}
</span></code></pre>
<p>That worked! There is enough conversions for our error types to get to where we need to get it.  The <code>ActixError</code> type has a few blanket conversions from common error types enough to be able to make this magic happen.</p>
<h2 id="getting-the-bounding-boxes-from-the-image">Getting the bounding boxes from the image</h2>
<p>At the core of it, we need to run the following:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img)
</span></code></pre>
<p>But we want this to run in a threadpool too:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>web</span><span style="color:#f29e74;">::</span><span>block(|| mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img))
</span></code></pre>
<p>Let's work through the function signature we'll need.  At a minimum we're gonna need the image, and the mtcnn struct.  Then we want to return a <code>Vec</code> of BBoxes.  We should try and keep our error types the same, so we'll use the ActixError type.</p>
<p>The function signature looks like this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_bboxes</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn) 
</span><span>  </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;, Error = ActixError&gt; 
</span></code></pre>
<p>We know that we'll need a <code>from_err()</code> on the <code>web::block</code> to convert the error type, and we'll have to use a <code>move</code> to give the image to the closure:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_bboxes</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;, Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">||</span><span> mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img))</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<p>But does this compile? Not yet:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>error[E0277]: `*mut tensorflow_sys::TF_Status` cannot be sent between threads safely
</span><span>  --&gt; src/main.rs:75:5
</span><span>   |
</span><span>75 |     web::block(move || mtcnn.run(&amp;img)).from_err()
</span><span>   |     ^^^^^^^^^^ `*mut tensorflow_sys::TF_Status` cannot be sent between threads safely
</span><span>   |
</span><span>   = help: within `tensorflow::Status`, the trait `std::marker::Send` is not implemented for `*mut tensorflow_sys::TF_Status`
</span><span>   = note: required because it appears within the type `tensorflow::Status`
</span><span>   = note: required by `actix_web::web::block`
</span></code></pre>
<p><code>tensorflow::Status</code>, which is the error type, can't be sent between threads.</p>
<p>Let's just shortcut here, and convert the error to a <code>String</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_bboxes</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;, Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">||</span><span> mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| e</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>()))</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<p>This allows us to move the <code>Result</code> across thread boundaries, as <code>String</code> does implement <code>Send</code></p>
<h2 id="returning-json-bboxes">Returning JSON BBoxes</h2>
<p>Ok, so we have 2 functions, one to get the image from the request, and one to get the bounding boxes.  We're gonna want to return json <code>HttpResponse</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">return_bboxes</span><span>(
</span><span>    </span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = HttpResponse, Error = ActixError&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Get the image from the input stream
</span><span>    </span><span style="color:#f28779;">get_image</span><span>(stream) 
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Get the bounding boxes from the image
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>img</span><span style="color:#f29e74;">| </span><span style="color:#f28779;">get_bboxes</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> mtcnn)) 
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Map the bounding boxes to a json HttpResponse
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">bboxes</span><span>| HttpResponse</span><span style="color:#f29e74;">::</span><span>Ok()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">json</span><span>(bboxes))
</span><span>}
</span></code></pre>
<p>Cool! Let's put this in our App definition:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>HttpServer</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>    App</span><span style="color:#f29e74;">::</span><span>new()
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">data</span><span>(mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span>()) 
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wrap</span><span>(middleware</span><span style="color:#f29e74;">::</span><span>Logger</span><span style="color:#f29e74;">::</span><span>default()) 
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// our new API service
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">service</span><span>(web</span><span style="color:#f29e74;">::</span><span>resource(</span><span style="color:#bae67e;">&quot;/api/v1/bboxes&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_async</span><span>(return_bboxes))
</span><span>})
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">bind</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>opt</span><span style="color:#f29e74;">.</span><span>listen)</span><span style="color:#f29e74;">?
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>()
</span></code></pre>
<p>And let's run it, using <code>curl</code> to submit a query to get some results back</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>$ curl --data-binary @rustfest.jpg  http://localhost:8000/api/v1/bboxes
</span><span>
</span><span>[{&quot;x1&quot;:471.4591,&quot;y1&quot;:287.59888,&quot;x2&quot;:495.3053,&quot;y2&quot;:317.25327,&quot;prob&quot;:0.9999908}....
</span></code></pre>
<p>Awesome! Using <a href="http://jmespath.org/">jmespath</a> to see we get our 120 faces back:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>$ curl -s --data-binary @rustfest.jpg  http://localhost:8000/api/v1/bboxes | jp &quot;length(@)&quot;
</span><span>120
</span></code></pre>
<h2 id="returning-an-overlay-image">Returning an Overlay Image</h2>
<p>The other API call we want is to return an image with the bounding boxes overlayed.  This is not much of a stretch, but the act of drawing boxes on an image is definitely a blocking action, so we'll need to do the same thing and send it to a thread pool.</p>
<p>Let's wrap our overlay function, converting it into a Future:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_overlay</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">bboxes</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;)
</span><span>   </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#ffa759;">u8</span><span>&gt;, Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>        </span><span style="color:#ffa759;">let</span><span> output_img </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">overlay</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>bboxes)</span><span style="color:#ccc9c2cc;">;
</span><span>        
</span><span>        </span><span style="color:#f29e74;">...
</span><span>
</span><span>    })</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<p>We're going to want to return a <code>Vec</code> of <code>u8</code> bytes so we can use this in the return body. So we'll need to allocate some buffer and instruct <code>image</code> to write out a JPEG from the image:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> buffer </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">vec!</span><span>[]</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>output_img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">write_to</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> buffer</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">JPEG</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// write out our buffer
</span><span>
</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(buffer)
</span></code></pre>
<p>Ok, so let's put our little function together and see if it compiles:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_overlay</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">bboxes</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;)
</span><span>  </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#ffa759;">u8</span><span>&gt;, Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>        </span><span style="color:#ffa759;">let</span><span> output_img </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">overlay</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>bboxes)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        </span><span style="color:#ffa759;">let mut</span><span> buffer </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        output_img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">write_to</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> buffer</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">JPEG</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// write out our buffer
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(buffer)
</span><span>    })</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<p>Not quite yet: we're missing a type annotation:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>error[E0282]: type annotations needed
</span><span>  --&gt; src/main.rs:82:5
</span><span>   |
</span><span>82 |     web::block(move || {
</span><span>   |     ^^^^^^^^^^ cannot infer type for `E`
</span></code></pre>
<p>Why is there an issue with the type? Well, it relates to this line here:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>Ok(buffer) // What&#39;s the `Error` type here?
</span></code></pre>
<p>At the moment, the only error type is from the <code>write_to</code> method which is <code>ImageError</code>.  But this line here doesn't have an error type, and could be anything.</p>
<p>There are 3 ways I can immediately think to handle this:</p>
<p><strong>Way Number 1</strong>: Declare the error type in <code>web::block</code></p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>web</span><span style="color:#f29e74;">::</span><span>block</span><span style="color:#f29e74;">::</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>,</span><span style="color:#f29e74;">_</span><span>,ImageError&gt;
</span></code></pre>
<p>This looks more like a turbosubmarine than a turbofish! But it compiles!</p>
<p><strong>Way Number 2</strong>: Declare the Result type with <code>as</code> </p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(buffer) </span><span style="color:#f29e74;">as </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>, ImageError&gt;
</span></code></pre>
<p><strong>Way Number 3</strong>: Use <code>map</code> to return the buffer on success:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>output_img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">write_to</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> buffer</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">JPEG</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|_| buffer)
</span></code></pre>
<p>I think for readability, #2 is probably easiest.  The <code>web::block</code> function takes 3 type arguments which can be confusing on first read of the code.  #3 is good too but I think it looks a bit strange.</p>
<p>Our final method looks like:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_overlay</span><span>(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage, </span><span style="color:#ffcc66;">bboxes</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;)
</span><span>   </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;</span><span style="color:#ffa759;">u8</span><span>&gt;, Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>        </span><span style="color:#ffa759;">let</span><span> output_img </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">overlay</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span>bboxes)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        </span><span style="color:#ffa759;">let mut</span><span> buffer </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#f29e74;">::</span><span>new()</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        output_img</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">write_to</span><span>(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span> buffer</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">JPEG</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Type annotations required for the `web::block`
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(buffer) </span><span style="color:#f29e74;">as </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#f29e74;">_</span><span>, ImageError&gt; 
</span><span>    })</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<h3 id="the-api-call">The API call</h3>
<p>Ok, we have our little futures that we need to return bounding boxes and image overlays.  Let's stitch this together and return a <code>HttpResponse</code>:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">return_overlay</span><span>(
</span><span>    </span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = HttpResponse, Error = ActixError&gt; {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">//... magic happens here
</span><span>}
</span></code></pre>
<p>Ok, first step is to get the image from the stream:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f28779;">get_image</span><span>(stream)
</span></code></pre>
<p>And Then once the future has resolved, we want to get the bounding boxes:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f28779;">get_image</span><span>(stream)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>img</span><span style="color:#f29e74;">| </span><span>{
</span><span>    </span><span style="color:#f28779;">get_bboxes</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> mtcnn)
</span><span>})
</span></code></pre>
<h3 id="moving-images-around">Moving Images Around</h3>
<p>Now we want to get the image overlay.  We have an issue though! we give the <code>get_bboxes</code> future our image, and it returns a Vec of bboxes, consuming the image.  There are a couple of options here.  We could <code>clone()</code> the image when we give it to bboxes, but that is duplicating memory.  We could wait for <code>Pin</code> and <code>async</code>/<code>await</code> to be finished and probably deal with it in an easier way then.</p>
<p>Or we could adjust our <code>get_bboxes</code> method to return a tuple of both the image and bounding boxes:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_bboxes</span><span>(
</span><span>    </span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">:</span><span> DynamicImage,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = (DynamicImage, </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span>&lt;BBox&gt;), Error = ActixError&gt; {
</span><span>    web</span><span style="color:#f29e74;">::</span><span>block(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>        mtcnn
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">run</span><span>(</span><span style="color:#f29e74;">&amp;</span><span>img)
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span>(|</span><span style="color:#ffcc66;">e</span><span>| e</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>())
</span><span>            </span><span style="font-style:italic;color:#5c6773;">//Return both the image and the bounding boxes
</span><span>            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">bboxes</span><span>| (img</span><span style="color:#ccc9c2cc;">,</span><span> bboxes))
</span><span>    })
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">from_err</span><span>()
</span><span>}
</span></code></pre>
<p>Making sure to update our <code>return_bboxes</code> function too:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">return_bboxes</span><span>(
</span><span>    </span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = HttpResponse, Error = ActixError&gt; {
</span><span>    </span><span style="color:#f28779;">get_image</span><span>(stream)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>img</span><span style="color:#f29e74;">| </span><span style="color:#f28779;">get_bboxes</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> mtcnn))
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|(</span><span style="color:#ffcc66;">_img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">bboxes</span><span>)| HttpResponse</span><span style="color:#f29e74;">::</span><span>Ok()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">json</span><span>(bboxes))
</span><span>}
</span></code></pre>
<h3 id="getting-the-overlay">Getting the Overlay</h3>
<p>It would be great if rust could desugar a tuple into command arguments.  Unfortunately not for us, so we will need to create a small closure:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">//Create our image overlay
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">bbox</span><span>)| </span><span style="color:#f28779;">get_overlay</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> bbox))
</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">buffer</span><span>| {
</span><span style="font-style:italic;color:#5c6773;">// Return a `HttpResponse` here
</span><span>})
</span></code></pre>
<h3 id="generating-the-response">Generating the Response</h3>
<p>Our <code>HttpResponse</code> needs to wrap the buffer into a Http Request with the buffer as the body:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>HttpResponse</span><span style="color:#f29e74;">::</span><span>with_body(StatusCode</span><span style="color:#f29e74;">::</span><span style="color:#ffcc66;">OK</span><span style="color:#ccc9c2cc;">,</span><span> buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span>())
</span></code></pre>
<p>Is that it? Well no, we have to set the content type header to be a jpeg:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let mut</span><span> response </span><span style="color:#f29e74;">= </span><span>HttpResponse</span><span style="color:#f29e74;">::</span><span>with_body(StatusCode</span><span style="color:#f29e74;">::</span><span style="color:#ffcc66;">OK</span><span style="color:#ccc9c2cc;">,</span><span> buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span>())</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>response
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">headers_mut</span><span>()
</span><span>    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span>(</span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">, </span><span>HeaderValue</span><span style="color:#f29e74;">::</span><span>from_static(</span><span style="color:#bae67e;">&quot;image/jpeg&quot;</span><span>))</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Ok now we can return the result:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">return_overlay</span><span>(
</span><span>    </span><span style="color:#ffcc66;">stream</span><span style="color:#ccc9c2cc;">: </span><span>web</span><span style="color:#f29e74;">::</span><span>Payload,
</span><span>    </span><span style="color:#ffcc66;">mtcnn</span><span style="color:#ccc9c2cc;">:</span><span> WebMtcnn,
</span><span>) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> impl Future&lt;Item = HttpResponse, Error = ActixError&gt; {
</span><span>    </span><span style="color:#f28779;">get_image</span><span>(stream)
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span>img</span><span style="color:#f29e74;">| </span><span>{
</span><span>            </span><span style="color:#f28779;">get_bboxes</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> mtcnn)
</span><span>        })
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span>(|(</span><span style="color:#ffcc66;">img</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">bbox</span><span>) | </span><span style="color:#f28779;">get_overlay</span><span>(img</span><span style="color:#ccc9c2cc;">,</span><span> bbox))
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">buffer</span><span>| {
</span><span>            </span><span style="color:#ffa759;">let mut</span><span> response </span><span style="color:#f29e74;">= </span><span>HttpResponse</span><span style="color:#f29e74;">::</span><span>with_body(StatusCode</span><span style="color:#f29e74;">::</span><span style="color:#ffcc66;">OK</span><span style="color:#ccc9c2cc;">,</span><span> buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span>())</span><span style="color:#ccc9c2cc;">;
</span><span>            response
</span><span>                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">headers_mut</span><span>()
</span><span>                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span>(</span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">, </span><span>HeaderValue</span><span style="color:#f29e74;">::</span><span>from_static(</span><span style="color:#bae67e;">&quot;image/jpeg&quot;</span><span>))</span><span style="color:#ccc9c2cc;">;
</span><span>            response
</span><span>        })
</span><span>}
</span></code></pre>
<p>And add that to our <code>App</code> builder:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span>HttpServer</span><span style="color:#f29e74;">::</span><span>new(</span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|| </span><span>{
</span><span>    App</span><span style="color:#f29e74;">::</span><span>new()
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">data</span><span>(mtcnn</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span>()) </span><span style="font-style:italic;color:#5c6773;">//Add in our data handler
</span><span>        </span><span style="font-style:italic;color:#5c6773;">//Add in a logger to see the requets coming through
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wrap</span><span>(middleware</span><span style="color:#f29e74;">::</span><span>Logger</span><span style="color:#f29e74;">::</span><span>default()) 
</span><span>        </span><span style="font-style:italic;color:#5c6773;">//JSON bounding boxes
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">service</span><span>(web</span><span style="color:#f29e74;">::</span><span>resource(</span><span style="color:#bae67e;">&quot;/api/v1/bboxes&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_async</span><span>(return_bboxes))
</span><span>        </span><span style="font-style:italic;color:#5c6773;">//Image overlay
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">service</span><span>(web</span><span style="color:#f29e74;">::</span><span>resource(</span><span style="color:#bae67e;">&quot;/api/v1/overlay&quot;</span><span>)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_async</span><span>(return_overlay))
</span><span>}
</span></code></pre>
<p>Great! Let's run it:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>$ curl --data-binary @rustfest.jpg  http://localhost:8000/api/v1/bboxes &gt; output.jpg
</span></code></pre>
<p>And we have our original overlay!</p>
<p><a href="/photos/rustfest_faces.jpg"><img src="/photos/rustfest_faces.jpg" alt="" /></a></p>
<h2 id="conclusions">Conclusions</h2>
<p>We stepped through converting a CLI app into a HTTP service, dipping our toes into the brave new async world.</p>
<p>As you can see, <a href="https://github.com/actix/actix-web/">actix web</a> is a very versatile web framework.  My interest in it was borne out of having all the features I need to build up web apps: multipart, thread pools, great efficiency.</p>
<p>While it is hard to bridge the sync and async gap, it's not impossible.  It would be great if there were some more ergonomic ways to do so, as I think a lot of developers struggle with this: I have seen a lot of questions around integrating with diesel and friends.</p>
<p>If you are looking for more actix web examples, the evergrowing examples repo is your best bet:</p>
<p><a href="https://github.com/actix/examples">https://github.com/actix/examples</a></p>
<p>I look forward to seeing what the community builds in the future!</p>

  </section>
</article>


    </div>
</body>

</html>