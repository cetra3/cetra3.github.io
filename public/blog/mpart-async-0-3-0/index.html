<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Lessons learnt updating a library to std::future - Cetra&#x27;s Thoughts </title>
    <link href="/spectre.css" rel="stylesheet">
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
</head>

<body>
    <header class="navbar">
        <section class="navbar-section">
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
    </header>
    <div class="container grid-lg">
        
<div class="post">
  <h1>Lessons learnt updating a library to std::future </h1>
  
  <p> <small class="label label-primary">rust</small> <small class="label label-primary">mpart-async</small> <small class="label">2020-01-22</small></p>
  
  <p>With the new <code>std::future</code> way of doing things and <a href="https://tokio.rs">tokio</a> slowly reaching maturation, it's time to look at updating the libraries out there that are using <em>the old ways</em>.  For one of my libraries, <a href="https://crates.io/crates/tmq">tmq</a>, a Tokio ZeroMQ library, there is some <a href="https://github.com/cetra3/tmq/pull/5">awesome work already done</a> to get this updated.</p>
<p>But, I thought it pertinent to at least get my feet in the water to see how hard it would be, from a library maintainer perspective, to update to <code>std::future</code>.  For this effort, I chose my small library: <a href="https://crates.io/crates/mpart-async">mpart-async</a>.   You can see the changes I have made by comparing the <a href="https://github.com/cetra3/mpart-async/compare/0.2.1...0.3.0">versions</a> here.  This blog is a small collection of notes &amp; gotches I found when porting code across.</p>
<p><code>mpart-async</code> is a <em>mostly</em> agnostic library for client side <code>multipart/form-data</code> requests.  There are existing libraries out there, like <a href="https://crates.io/crates/multipart">multipart</a>, but I found the API a little unwieldy for my taste (That: and async support is <a href="https://github.com/abonander/multipart-async">still in alpha</a> according to the readme). I wanted something that worked, and was simple, but didn't offer an opinion on the web client. I use both the <a href="https://github.com/actix/actix-web/tree/master/awc">actix client</a> &amp;  <a href="https://crates.io/crates/hyper">hyper</a> to make multipart requests depending on the project.</p>
<p>The challenge is that with multipart requests you mostly have fields &amp; binary files.  For binary files, you can appreciate, should not be buffered entirely in memory, but streamed out as the bytes become available.  So <code>mpart-async</code> works with multiple internal streams of files and also provides a <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs">convenience wrapper</a> (if using tokio) for sending files given a path.</p>
<h2 id="a-new-example">A New Example</h2>
<p>All these changes to support <code>async fn</code> and is it actually easier to consume/use async libraries?</p>
<p>Given the <a href="https://crates.io/crates/hyper">hyper</a> example, I would say yes.</p>
<p>Compare the <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/examples/hyper.rs">new example</a>:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2cc;">#</span><span style="color:#ccc9c2;">[</span><span style="color:#ffd580;">tokio</span><span style="color:#ccc9c2;">::</span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">]
async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Result&lt;(), Error&gt; {
    </span><span style="font-style:italic;color:#5c6773;">//Setup a mock server to accept connections.
    //....

    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> client </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Client</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;

    </span><span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> mpart </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">MultipartRequest</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">default()</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">

    mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_field</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;foo&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;bar&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
    mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_file</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;test&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;

    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> request </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Request</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">post(</span><span style="color:#bae67e;">&quot;http://localhost:3000&quot;</span><span style="color:#ccc9c2;">)
        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">header</span><span style="color:#ccc9c2;">(
            </span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;multipart/form-data; boundary=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">get_boundary</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">)
        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">body</span><span style="color:#ccc9c2;">(Body</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">wrap_stream(mpart))</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">

    client</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request</span><span style="color:#ccc9c2;">(request)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(())
}
</span></pre>
<p>With the <a href="https://github.com/cetra3/mpart-async/blob/c928f015fa31cd57533d4ba43551a9a96b61b0a2/examples/hyper.rs">older one</a>:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="font-style:italic;color:#5c6773;">// current_thread::Runtime can&#39;t be used because of the blocking file operations
    </span><span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> rt </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Runtime</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;new rt&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">//Setup a mock server to accept connections.
    //....

    // Open `Cargo.toml` file and create a request
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> request </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">File</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">open(</span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span style="color:#ccc9c2;">)
        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">e</span><span style="color:#ccc9c2;">| </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> e))
        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">file</span><span style="color:#ccc9c2;">| {
            </span><span style="font-style:italic;color:#5c6773;">// A Stream of BytesMut decoded from an AsyncRead
            </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> framed </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">FramedRead</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(file</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">BytesCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new())</span><span style="color:#ccc9c2cc;">;

            </span><span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> mpart </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">MultipartRequest</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">default()</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
            mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_field</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;foo&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;bar&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
            mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">add_stream</span><span style="color:#ccc9c2;">(
                </span><span style="color:#bae67e;">&quot;foofile&quot;</span><span style="color:#ccc9c2cc;">,
                </span><span style="color:#bae67e;">&quot;Cargo.toml&quot;</span><span style="color:#ccc9c2cc;">,
                </span><span style="color:#bae67e;">&quot;application/toml&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;">
                framed</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">b</span><span style="color:#ccc9c2;">| b</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">freeze</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;
            </span><span style="color:#ccc9c2;">Request</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">post(</span><span style="color:#bae67e;">&quot;http://localhost:3000&quot;</span><span style="color:#ccc9c2;">)
                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">header</span><span style="color:#ccc9c2;">(
                    </span><span style="color:#ffcc66;">CONTENT_TYPE</span><span style="color:#ccc9c2cc;">,
                    </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;multipart/form-data; boundary=</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> mpart</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">get_boundary</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
                </span><span style="color:#ccc9c2;">)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">body</span><span style="color:#ccc9c2;">(Body</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">wrap_stream(mpart))
                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_future</span><span style="color:#ccc9c2;">()
                </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">e</span><span style="color:#ccc9c2;">| </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> e))
        })</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// Send request
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> task </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> request</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">request</span><span style="color:#ccc9c2;">| {
        </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> client </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">hyper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Client</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
        client
            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">request</span><span style="color:#ccc9c2;">(request)
            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">e</span><span style="color:#ccc9c2;">| </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> e))
            </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">response</span><span style="color:#ccc9c2;">| {
                response
                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_body</span><span style="color:#ccc9c2;">()
                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">concat2</span><span style="color:#ccc9c2;">()
                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">e</span><span style="color:#ccc9c2;">| </span><span style="color:#f28779;">format!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;</span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> e))
                    </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">and_then</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">body</span><span style="color:#ccc9c2;">| {
                        </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(data) </span><span style="color:#f29e74;">= </span><span style="color:#ffa759;">str</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from_utf8(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ccc9c2;">body) {
                            </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Response: </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> data)</span><span style="color:#ccc9c2cc;">;
                        </span><span style="color:#ccc9c2;">}
                        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(())
                    })
            })
    })</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">

    rt</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">block_on</span><span style="color:#ccc9c2;">(task)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">expect</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;request failed&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></pre>
<p>While there are still a few warts (such as having to manually add the boundary header), I find the code a lot more readable and easy to follow, rather than your standard combinator paths.</p>
<h2 id="no-more-error-associated-type">No more <code>Error</code> Associated Type</h2>
<p>The most drastic change to the <code>Stream</code> trait is that there is no longer an <code>Error</code> associated type.  The old <code>Stream</code>/<code>Future</code> traits had both <code>Item</code> and <code>Error</code>, as it assumed that streams were always going to be fallible.  The new traits do away with the <code>Error</code> associated type.  Instead, if you want your <code>Stream</code> to possibly be an error then you need to return a <code>Result</code> as your <code>Item</code> type.</p>
<p>For the <code>Stream</code> trait, the method you implement has changed to <code>poll_next</code> and uses the <code>std::task::Poll</code> enum as a return type.</p>
<p>The <code>Poll</code> enum did feel a little inside out when I started using it, but makes sense in terms of there being no <code>Error</code> type.  You don't return a <code>Result&lt;Async&lt;Option&gt;, _&gt;...</code> you instead return a <code>Poll&lt;Option&lt;Result&lt;_,_&gt;&gt;&gt;</code>.</p>
<p>Generally, this means if you wrote this:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">return </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(Async</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(bytes)))
</span></pre>
<p>You instead will return:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">return </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(bytes)))
</span></pre><h2 id="streamext-traits-and-friends"><code>StreamExt</code> traits and friends</h2>
<p>As a consequence of no <code>Error</code> associated type, and an example of different ergonomics, if you are dealing with <code>Result</code> items, you may want to use the <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html">TryStreamExt</a> trait instead of <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.StreamExt.html">StreamExt</a>.  They are basically the same trait but one deals with <code>Result</code> a bit more nicely.  I'm not sure whether a simpler solution will be possible with higher kinded types in the future, but for now it is a tiny bit more complex than futures 0.1.</p>
<p>Interestingly, the <a href="https://docs.rs/futures/0.3.1/futures/stream/index.html">index page</a> for stream docs doesn't currently mention that the <code>TryStreamExt</code> trait exists &amp; I only found out about it by asking questions in the <a href="https://discord.gg/tokio">discord chat</a>.</p>
<p>But wait, there is also <a href="https://docs.rs/tokio/0.2.10/tokio/stream/trait.StreamExt.html">StreamExt</a> from tokio  which is subtly different, but does as of <code>0.2.10</code> allow you to run <code>collect()</code> on <code>Result&lt;Bytes, _&gt;</code> item streams.</p>
<p>When would you use either <code>StreamExt</code>?  I would say that if you want to be more general, you should probably use the <code>futures</code>  implementation.  Bearing in mind you can't run <a href="https://docs.rs/futures/0.3.1/futures/stream/trait.TryStreamExt.html#method.try_collect"><code>try_collect()</code></a> on <code>Result&lt;Bytes, _&gt;</code> at the moment due to an <a href="https://github.com/tokio-rs/bytes/issues/324">outstanding issue</a> with the bytes crate.  Why does this matter? Well, <a href="https://hyper.rs/">hyper</a> passes around streams of <code>Result&lt;Bytes, _&gt;</code> when you are streaming a body in &amp; out of a request.  Working with this particular stream signature is a bit clunky still, but I'm sure that this will be resolved in due course.</p>
<p>So we have:</p>
<ul>
<li><code>StreamExt</code> from <code>futures</code> that works on <code>Stream</code> that aren't <code>Result</code></li>
<li><code>TryStreamExt</code> from <code>futures</code> that works on <code>Stream</code> that are <code>Result</code> but doesn't work well with <code>Result&lt;Bytes,_&gt;</code> when trying to <code>try_collect()</code></li>
<li><code>StreamExt</code> from <code>tokio</code> that works with <code>Result&lt;Bytes,_&gt;</code> and allows you to <code>collect()</code> to get the output but now means you have a dependency on <code>tokio</code></li>
</ul>
<p>This might end up confusing more than just me, and I do hope that it's simplified in the future.</p>
<p>Luckily in the core of the API I don't need to use them, only for tests &amp; filestream, which means I'm quite happy to depend on the <code>tokio</code> implementation.</p>
<h2 id="wrapping-inner-streams-in-pin">Wrapping inner streams in <code>Pin</code></h2>
<p>I got tripped up on this for a while, and needed to again ask in chat for the answer here. If you have an inner stream and you want to call <code>poll_next</code> on it, you need to wrap it in a <code>Pin</code>, otherwise the <code>Stream</code> trait does not stick and you will get some gnarly error message with some weird suggestions:</p>
<p>The my original shot at the code was:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">stream</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">stream</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx)
</span></pre>
<p>But it needs to be:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">Pin</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> stream</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">stream)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx)
</span></pre>
<p>The compiler error message is not too helpful here, and insists I restrict <code>S</code> by <code>Stream</code>, even though it is already restricted by <code>Stream</code>.</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">error[E0599]: no method named `poll_next` found for type `S` in the current scope
   --&gt; src/lib.rs:282:41
    |
282 |                     match stream.stream.poll_next(cx) {
    |                                         ^^^^^^^^^ method not found in `S`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `poll_next`, perhaps you need to restrict type parameter `S` with it:
    |
254 | impl&lt;E, S: futures::Stream + Stream&gt; Stream for MultipartRequest&lt;S&gt;
    |         ^^^^^^^^^^^^^^^^^^^^
</span></pre>
<p>You need to make sure that your inner stream implements <code>Unpin</code> as well to go down this path:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">impl</span><span style="color:#ccc9c2;">&lt;E, S&gt; Stream </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">MultipartRequest</span><span style="color:#ccc9c2;">&lt;S&gt;
</span><span style="color:#ffa759;">where</span><span style="color:#ccc9c2;">
    S</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Stream&lt;Item = Result&lt;Bytes, E&gt;&gt; + Unpin,
</span></pre><h2 id="storing-the-results-from-an-async-fn-in-a-struct">Storing the results from an <code>async fn</code> in a struct</h2>
<p>Some of the methods in tokio are returns from an <code>async fn</code> , like the <a href="https://docs.rs/tokio/0.2.10/tokio/fs/struct.File.html#method.open">File::open</a> method, which I use for <code>FileStream</code>.  I found the answer on <a href="https://stackoverflow.com/questions/58354633/cannot-use-impl-future-to-store-async-function-in-a-vector">stack overflow</a> as to how to do this with <code>std::future</code>, since <code>async fn</code> returns an opaque type.</p>
<p>For the older version, the OpenFuture was a concrete type:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">FileStream </span><span style="color:#ccc9c2;">{
    inner</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Option&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
    file</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">OpenFuture&lt;PathBuf&gt;,
}
</span></pre>
<p>The newer version is a return from an <code>async fn</code> and is opaque, so we wrap it using <code>Box::pin</code>:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">FileStream </span><span style="color:#ccc9c2;">{
    inner</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Option&lt;FramedRead&lt;File, BytesCodec&gt;&gt;,
    file</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;File, Error&gt;&gt; </span><span style="color:#f29e74;">+</span><span style="color:#ccc9c2;"> Send </span><span style="color:#f29e74;">+</span><span style="color:#ccc9c2;"> Sync&gt;&gt;,
}
</span></pre>
<p>You can then instantiate this with:</p>
<pre style="background-color:#212733;">
<span style="font-style:italic;color:#5ccfe6;">Box</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">pin(File</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">open(file</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">()))
</span></pre>
<p>Then it's easy to call passing on the context from an existing <code>poll()</code>:</p>
<pre style="background-color:#212733;">
<span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">file</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">as_mut</span><span style="color:#ccc9c2;">()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll</span><span style="color:#ccc9c2;">(cx)
</span></pre><h2 id="notifying-a-task">Notifying a task</h2>
<p><code>FileStream</code> has two stages.  One is the future to open the file. The second is streaming out the bytes of the file.  When the future resolves to open the file, I want to notify the context that it should be polled again to start streaming.</p>
<p>The old way of doing this was <code>task::current().notify()</code>:</p>
<pre style="background-color:#212733;">
<span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">inner </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(FramedRead</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(file</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">BytesCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()))</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">task</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">current()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">notify</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span></pre>
<p>The new way appears to be using  <code>cx.waker().wake_by_ref()</code> where <code>cx</code> is the context received from the poll:</p>
<pre style="background-color:#212733;">
<span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">inner </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(FramedRead</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(file</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">BytesCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()))</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
cx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">waker</span><span style="color:#ccc9c2;">()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wake_by_ref</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span></pre>
<p>I say appears because the test written works without <code>wake_by_ref()</code> being called.  Requires a bit more investigation here I think to know exactly what's going on.  My <a href="https://github.com/cetra3/mpart-async/blob/981ba0437e19fa47f94a913cf9aaa4717fbe12bc/src/filestream.rs#L56">simple test example</a> works either way, strangely.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is not too onerous to convert to <code>std::future</code> for an existing library.  I would assume the leap from the old <code>tokio-core</code> would be harder, as the changes <em>feel</em> mostly cosmetic here.</p>
<p>The omission of the <code>Error</code> associated type to me actually makes things less ergonomic and things a little more fragmented (as evidenced by 3 <code>*StreamExt</code> traits..).  I was an advocate of this initially, but there probably needs to be a bit more work in making this nicer.</p>
<p>There are still a lot of libraries out there that will be required to be updated, a lot of old blogs that are no longer relevant, and a lot of exploration that needs to be done to see how the async ecosystem falls out.  But considering the friction of updating is quite small, I am quitely optimistic!</p>


</div>

    </div>
</body>

</html>