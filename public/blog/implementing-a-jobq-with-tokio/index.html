<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing a Job queue with Tokio-Serde</title>
    <meta name="description" content="An async background job queue written with tokio-serde" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:0.67em 0}figcaption,figure,main{display:block}hr{box-sizing:content-box;height:0;overflow:visible}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}address{font-style:normal}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:"SF Mono","Segoe UI Mono","Roboto Mono",Menlo,Courier,monospace;font-size:1em}dfn{font-style:italic}small{font-size:80%;font-weight:400}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}fieldset{border:0;margin:0;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{display:inline-block;vertical-align:baseline}textarea{overflow:auto}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details,menu{display:block}summary{display:list-item;outline:none}canvas{display:inline-block}template{display:none}[hidden]{display:none}*,*::before,*::after{box-sizing:inherit}html{box-sizing:border-box;font-size:20px;line-height:1.5;-webkit-tap-highlight-color:transparent}body{background:#303742;color:#fff;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;font-size:.8rem;overflow-x:hidden;text-rendering:optimizeLegibility}a{color:#73c6ec;outline:none;text-decoration:none}a:focus{box-shadow:0 0 0 0.1rem rgba(115,198,236,0.2)}a:focus,a:hover,a:active,a.active{color:#46b4e6;text-decoration:underline}a:visited{color:#a0d8f2}h1,h2,h3,h4,h5,h6{color:inherit;font-weight:700;line-height:1.2;margin-bottom:.5rem;margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{font-weight:700}h1,.h1{font-size:2rem}h2,.h2{font-size:1.6rem}h3,.h3{font-size:1.4rem}h4,.h4{font-size:1.2rem}h5,.h5{font-size:1rem}h6,.h6{font-size:.8rem}p{margin:0 0 1.2rem}a,ins,u{text-decoration-skip:ink edges}abbr[title]{border-bottom:.05rem dotted;cursor:help;text-decoration:none}kbd{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#303742;color:#fff;font-size:.7rem}mark{background:#ffe9b3;color:#fff;border-bottom:.05rem solid #ffd367;border-radius:.1rem;padding:.05rem .1rem 0}blockquote{border-left:.1rem solid #dadee4;margin-left:0;padding:.4rem .8rem}blockquote p:last-child{margin-bottom:0}ul,ol{margin:.8rem 0 .8rem .8rem;padding:0}ul ul,ul ol,ol ul,ol ol{margin:.8rem 0 .8rem .8rem}ul li,ol li{margin-top:.4rem}ul{list-style:disc inside}ul ul{list-style-type:circle}ol{list-style:decimal inside}ol ol{list-style-type:lower-alpha}dl dt{font-weight:bold}dl dd{margin:.4rem 0 .8rem 0}.btn{appearance:none;background:#fff;border:.05rem solid #73c6ec;border-radius:.1rem;color:#73c6ec;cursor:pointer;display:inline-block;font-size:.8rem;height:2.5rem;line-height:1.2rem;outline:none;padding:.6rem .4rem;text-align:center;text-decoration:none;transition:background .2s, border .2s, box-shadow .2s, color .2s;user-select:none;vertical-align:middle;white-space:nowrap}.btn:focus{box-shadow:0 0 0 0.1rem rgba(115,198,236,0.2)}.btn:focus,.btn:hover{background:#fff;border-color:#66c1ea;text-decoration:none}.btn:active,.btn.active{background:#66c1ea;border-color:#4fb7e7;color:#fff;text-decoration:none}.btn:active.loading::after,.btn.active.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn[disabled],.btn:disabled,.btn.disabled{cursor:default;opacity:.5;pointer-events:none}.btn.btn-primary{background:#73c6ec;border-color:#66c1ea;color:#fff}.btn.btn-primary:focus,.btn.btn-primary:hover{background:#5dbde9;border-color:#4fb7e7;color:#fff}.btn.btn-primary:active,.btn.btn-primary.active{background:#54b9e8;border-color:#46b4e6;color:#fff}.btn.btn-primary.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-success{background:#32b643;border-color:#2faa3f;color:#fff}.btn.btn-success:focus{box-shadow:0 0 0 0.1rem rgba(50,182,67,0.2)}.btn.btn-success:focus,.btn.btn-success:hover{background:#30ae40;border-color:#2da23c;color:#fff}.btn.btn-success:active,.btn.btn-success.active{background:#2a9a39;border-color:#278e34;color:#fff}.btn.btn-success.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-error{background:#e85600;border-color:#d95000;color:#fff}.btn.btn-error:focus{box-shadow:0 0 0 0.1rem rgba(232,86,0,0.2)}.btn.btn-error:focus,.btn.btn-error:hover{background:#de5200;border-color:#cf4d00;color:#fff}.btn.btn-error:active,.btn.btn-error.active{background:#c44900;border-color:#b54300;color:#fff}.btn.btn-error.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-link{background:transparent;border-color:transparent;color:#73c6ec}.btn.btn-link:focus,.btn.btn-link:hover,.btn.btn-link:active,.btn.btn-link.active{color:#46b4e6}.btn.btn-sm{font-size:.7rem;height:1.4rem;padding:.05rem .3rem}.btn.btn-lg{font-size:.9rem;height:2rem;padding:.35rem .6rem}.btn.btn-block{display:block;width:100%}.btn.btn-action{width:2.5rem;padding-left:0;padding-right:0}.btn.btn-action.btn-sm{width:1.4rem}.btn.btn-action.btn-lg{width:2rem}.btn.btn-clear{background:transparent;border:0;color:currentColor;height:1rem;line-height:.8rem;margin-left:.2rem;margin-right:-2px;opacity:1;padding:.1rem;text-decoration:none;width:1rem}.btn.btn-clear:focus,.btn.btn-clear:hover{background:rgba(48,55,66,0.5);opacity:.95}.btn.btn-clear::before{content:"\2715"}.btn-group{display:inline-flex;flex-wrap:wrap}.btn-group .btn{flex:1 0 auto}.btn-group .btn:first-child:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group .btn:not(:first-child):not(:last-child){border-radius:0;margin-left:-.05rem}.btn-group .btn:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-.05rem}.btn-group .btn:focus,.btn-group .btn:hover,.btn-group .btn:active,.btn-group .btn.active{z-index:1}.btn-group.btn-group-block{display:flex}.btn-group.btn-group-block .btn{flex:1 0 0}.label{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#39414e;color:#e6e6e6;display:inline-block}.label.label-rounded{border-radius:5rem;padding-left:.4rem;padding-right:.4rem}.label.label-primary{background:#0b3e55;color:#fff}.label.label-secondary{background:#fff;color:#73c6ec}.label.label-success{background:#32b643;color:#fff}.label.label-warning{background:#ffb700;color:#fff}.label.label-error{background:#e85600;color:#fff}code{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#0f4e6b;color:#fff;font-size:85%}.code{border-radius:.1rem;color:#fff;position:relative}.code::before{color:#bcc3ce;content:attr(data-lang);font-size:.7rem;position:absolute;right:.4rem;top:.1rem}.code code{background:#303742;color:inherit;display:block;line-height:1.5;overflow-x:auto;padding:1rem;width:100%}.container{margin-left:auto;margin-right:auto;padding-left:.4rem;padding-right:.4rem;width:100%}.container.grid-xl{max-width:1296px}.container.grid-lg{max-width:976px}.container.grid-md{max-width:856px}.container.grid-sm{max-width:616px}.container.grid-xs{max-width:496px}.show-xs,.show-sm,.show-md,.show-lg,.show-xl{display:none !important}.columns{display:flex;flex-wrap:wrap;margin-left:-.4rem;margin-right:-.4rem}.columns.col-gapless{margin-left:0;margin-right:0}.columns.col-gapless>.column{padding-left:0;padding-right:0}.columns.col-oneline{flex-wrap:nowrap;overflow-x:auto}.column{flex:1;max-width:100%;padding-left:.4rem;padding-right:.4rem}.column.col-12,.column.col-11,.column.col-10,.column.col-9,.column.col-8,.column.col-7,.column.col-6,.column.col-5,.column.col-4,.column.col-3,.column.col-2,.column.col-1{flex:none}.col-12{width:100%}.col-11{width:91.66666667%}.col-10{width:83.33333333%}.col-9{width:75%}.col-8{width:66.66666667%}.col-7{width:58.33333333%}.col-6{width:50%}.col-5{width:41.66666667%}.col-4{width:33.33333333%}.col-3{width:25%}.col-2{width:16.66666667%}.col-1{width:8.33333333%}.col-auto{flex:0 0 auto;max-width:none;width:auto}.col-mx-auto{margin-left:auto;margin-right:auto}.col-ml-auto{margin-left:auto}.col-mr-auto{margin-right:auto}@media (max-width: 1280px){.col-xl-12,.col-xl-11,.col-xl-10,.col-xl-9,.col-xl-8,.col-xl-7,.col-xl-6,.col-xl-5,.col-xl-4,.col-xl-3,.col-xl-2,.col-xl-1{flex:none}.col-xl-12{width:100%}.col-xl-11{width:91.66666667%}.col-xl-10{width:83.33333333%}.col-xl-9{width:75%}.col-xl-8{width:66.66666667%}.col-xl-7{width:58.33333333%}.col-xl-6{width:50%}.col-xl-5{width:41.66666667%}.col-xl-4{width:33.33333333%}.col-xl-3{width:25%}.col-xl-2{width:16.66666667%}.col-xl-1{width:8.33333333%}.hide-xl{display:none !important}.show-xl{display:block !important}}@media (max-width: 960px){.col-lg-12,.col-lg-11,.col-lg-10,.col-lg-9,.col-lg-8,.col-lg-7,.col-lg-6,.col-lg-5,.col-lg-4,.col-lg-3,.col-lg-2,.col-lg-1{flex:none}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.hide-lg{display:none !important}.show-lg{display:block !important}}@media (max-width: 840px){.col-md-12,.col-md-11,.col-md-10,.col-md-9,.col-md-8,.col-md-7,.col-md-6,.col-md-5,.col-md-4,.col-md-3,.col-md-2,.col-md-1{flex:none}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.hide-md{display:none !important}.show-md{display:block !important}}@media (max-width: 600px){.col-sm-12,.col-sm-11,.col-sm-10,.col-sm-9,.col-sm-8,.col-sm-7,.col-sm-6,.col-sm-5,.col-sm-4,.col-sm-3,.col-sm-2,.col-sm-1{flex:none}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.hide-sm{display:none !important}.show-sm{display:block !important}}@media (max-width: 480px){.col-xs-12,.col-xs-11,.col-xs-10,.col-xs-9,.col-xs-8,.col-xs-7,.col-xs-6,.col-xs-5,.col-xs-4,.col-xs-3,.col-xs-2,.col-xs-1{flex:none}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.hide-xs{display:none !important}.show-xs{display:block !important}}.navbar{align-items:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin-left:auto;margin-right:auto;max-width:960px}.navbar .navbar-section{align-items:center;display:flex;flex:1 0 0}.navbar .navbar-section:not(:first-child):last-child{justify-content:flex-end}.navbar .navbar-center{align-items:center;display:flex;flex:0 0 auto}.navbar .navbar-brand{font-size:.9rem;text-decoration:none}pre{padding:0.5rem 0.5rem;border-radius:.3rem;overflow-y:auto}.post header{border-radius:.3rem;padding:0.5rem;margin-bottom:0.5rem}.post header h1{margin-bottom:0}.post section{padding:0.5rem;background-color:#2a3039;border-radius:.3rem}.post img{width:100%}.post .utterances{max-width:none !important}.card{margin-bottom:0.5rem}.main-header{margin-bottom:0.5rem;background-color:#272d36;box-shadow:0 20rem 20rem 20rem rgba(115,198,236,0.2)}.card{background:#2a3039;border-radius:.3rem;display:flex;flex-direction:column}.card .card-header,.card .card-body,.card .card-footer{padding:.8rem;padding-bottom:0}.card .card-header:last-child,.card .card-body:last-child,.card .card-footer:last-child{padding-bottom:.8rem}.card .card-body{flex:1 1 auto}.card .card-image{padding-top:.8rem}.card .card-image:first-child{padding-top:0}.card .card-image:first-child img{border-top-left-radius:.1rem;border-top-right-radius:.1rem}.card .card-image:last-child img{border-bottom-left-radius:.1rem;border-bottom-right-radius:.1rem}
</style>
</head>

<body>
    <header class="main-header">
        <div class="navbar">
        <section class="navbar-section">
            <img src="/favicon.svg" width="30" height="30"/>
            <a href="/" class="btn btn-link">Home</a>
            <a href="/blog/" class="btn btn-link">Blogs</a>
            <a href="/rss.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
        </div>
    </header>
    <div class="container grid-lg">
        
<article class="post">
  <header>
  <h1>Implementing a Job queue with Tokio-Serde </h1>
  <em>An async background job queue written with tokio-serde</em>
  <br />
  
  <small class="label label-primary">rust</small> <small class="label label-primary">async</small> <small class="label">2020-05-13</small>
  
  </header>
  <section>
    <p>In the <a href="../implementing-a-jobq/">last blog</a> of this series, I implemented job queue with <a href="https://github.com/cetra3/tmq">tmq</a>.  I noted back then that <strong>tmq</strong> is great if you need to interact with other languages, but may be a little overkill if you are just using rust.  I wondered what it'd take to build the job queue with a smaller library footprint, using something like <a href="https://github.com/carllerche/tokio-serde">tokio-serde</a> instead of <a href="https://github.com/cetra3/tmq">tmq</a>.  It was successful, and this blog will step through some of the changes needed.</p>
<p>To follow along, these changes are on the <code>tokio_serde</code> branch of the <a href="https://github.com/cetra3/jobq/tree/tokio_serde">jobq repo</a>.</p>
<p>If you are getting lost make sure you <a href="../implementing-a-jobq/">review the last blog</a> to see some of the logic &amp; design tradeoffs.</p>
<h2 id="what-is-tokio-serde">What is Tokio-Serde</h2>
<p><strong>Tokio-Serde</strong> is a little glue library that allows you to serialise/deserialise objects on the wire. With the help of <a href="https://docs.rs/tokio-util/0.3.1/tokio_util/codec/index.html">tokio-util's codec feature</a>, you can use <em>Tokio-Serde</em> to encode/decode bytes into discrete messages to be passed on the wire.</p>
<p>From the <em>Tokio-Serde</em> <a href="https://docs.rs/tokio-serde/">documentation</a> using tokio-serde is 3 layers deep:</p>
<ul>
<li><code>tokio::net::TcpStream</code>: The raw Stream/Sink where we can get/send bytes</li>
<li><code>tokio_util::codec::Framed</code>: The ability to chunk bytes into discrete frames</li>
<li><code>tokio_serde::Framed</code>: The ability to take these frames &amp; then serialize/deserialize them</li>
</ul>
<h3 id="the-tcp-stream">The TCP Stream</h3>
<p>The TCP stream is your standard tcp connection.  In tokio, you can either <code>bind</code> or <code>connect</code> to a TCP socket.</p>
<p>With <code>connect</code>, you will get a straight tcp stream, if successful:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> tcp_stream </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">TcpStream</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">connect(</span><span style="color:#bae67e;">&quot;127.0.0.1:17653&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
</span></pre>
<p>With <code>bind</code> you will get a listener, which will produce tcp streams when new connections come in:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> listener </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">TcpListener</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">bind(</span><span style="color:#bae67e;">&quot;127.0.0.1:17653&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">while let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(tcp_stream) </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> listener</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_next</span><span style="color:#ccc9c2;">()</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">? </span><span style="color:#ccc9c2;">{
    </span><span style="font-style:italic;color:#5c6773;">//do something with the tcp stream
</span><span style="color:#ccc9c2;">}
</span></pre><h3 id="the-frame">The Frame</h3>
<p>Ok so we have bytes coming across the wire now from our standard TCP stream.  As bytes come in, the tcp stream will be woken up so work can commence on it.  But TCP streams do not have a beginning or end, they are just a stream of bytes. We need something to <em>break</em> up this stream of bytes into discrete objects.  This is where <code>tokio_util::codec::Framed</code> comes in: it chunks down bytes on the wire into frames.</p>
<p>The <code>tokio_util</code> crate comes with the <a href="https://docs.rs/tokio-util/0.3.1/tokio_util/codec/trait.Encoder.html">Encoder</a>/<a href="https://docs.rs/tokio-util/0.3.1/tokio_util/codec/trait.Decoder.html">Decoder</a> traits which allow you to implement this.  <code>tokio-util</code> also comes with a simple, <a href="https://docs.rs/tokio-util/0.3.1/tokio_util/codec/length_delimited/index.html">Length Delimited Codec</a> which, on the wire looks like this:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">+----------+--------------------------------+
| length   |          payload               |
+----------+--------------------------------+
</span></pre>
<p>When decoding, this will read the length header, allocate some memory and wait until the payload is fully delivered.  If there are not enough bytes on the wire to do this, then it will be continuously polled until it is ready, keeping around a buffer. The semantics of <code>Decoder</code> mean that if you return no bytes, then it's an indication there needs to be more to decode a frame successfully.</p>
<p>When encoding, the whole thing is ready to go, so tack on the length, your payload and let tokio handle the rest.</p>
<h3 id="the-serde-frame">The Serde Frame</h3>
<p>We now have some raw bytes that have been bundled into frames which can be encoded/decoded from the raw bytes into something more meaningful.  Rather than implement this by hand, we can rely on <code>tokio-serde</code> with one of the existing codecs, such as JSON, CBOR, Bincode or Messagepack.</p>
<p>Our existing job queue uses CBOR so we'll use that here as well.  We can use the same messages <a href="https://github.com/cetra3/jobq/blob/master/src/lib.rs">we have previously used</a> but we will condense down the Client/Worker to just <a href="https://github.com/cetra3/jobq/blob/518c6c025a9e10477819fcc87acf8747383e9ba3/src/lib.rs#L21-L25"><code>ClientMessage</code></a>:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2cc;">#</span><span style="color:#ccc9c2;">[</span><span style="color:#ffd580;">derive</span><span style="color:#ccc9c2;">(Serialize</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> Deserialize</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> Debug)]
</span><span style="color:#ffa759;">pub enum </span><span style="color:#73d0ff;">ServerMessage </span><span style="color:#ccc9c2;">{
    Hello(</span><span style="font-style:italic;color:#5ccfe6;">String</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5c6773;">// Hello with client name
</span><span style="color:#ccc9c2;">    Request(JobRequest)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;">
    Completed(Job)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;">
    Failed(Job</span><span style="color:#ccc9c2cc;">, </span><span style="font-style:italic;color:#5ccfe6;">String</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ccc9c2cc;">#</span><span style="color:#ccc9c2;">[</span><span style="color:#ffd580;">derive</span><span style="color:#ccc9c2;">(Serialize</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> Deserialize</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> Debug)]
</span><span style="color:#ffa759;">pub enum </span><span style="color:#73d0ff;">ClientMessage </span><span style="color:#ccc9c2;">{
    Hello(</span><span style="font-style:italic;color:#5ccfe6;">String</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;">
    Order(Job)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;">
    Acknowledged(Job)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">}
</span></pre>
<p>Putting these 3 layers together, we get a <code>Stream</code>/<code>Sink</code> we can send values to:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> tcp_stream </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">TcpStream</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">connect(addr)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> length_delimited </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">tokio_util</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">codec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Framed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(tcp_stream</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">LengthDelimitedCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new())</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> connection </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">tokio_serde</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Framed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(length_delimited</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">Cbor</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">default())</span><span style="color:#ccc9c2cc;">;
</span></pre>
<p>With that we have our transport that we want: length delimited cbor frames.  On the wire this is not too different to ZeroMQ, but would probably shave a few bytes here and there.  Now we need to implement the Server/Client components.</p>
<h2 id="implementing-a-server">Implementing a Server</h2>
<p>We want to accept connections from clients/workers and then route out messages to the appropriate connection.  We will leave the server logic itself <em>mostly</em> untouched, and instead replace the <code>tmq::router</code> with a new <a href="https://github.com/cetra3/jobq/blob/tokio_serde/src/router.rs"><code>Router</code></a>  struct which uses <code>tokio-serde</code></p>
<h3 id="the-router">The Router</h3>
<p>The <a href="https://github.com/cetra3/jobq/blob/tokio_serde/src/router.rs"><code>Router</code></a> struct handles incoming client connections and allows our server logic to send messages based upon their name.</p>
<p>We have multiple <em>clients/workers</em> that will be connecting to our jobq server so we will need to keep around some state to handle those connections.  How will we do that? Well, a simple <code>HashMap&lt;String, Connection&gt;</code> is probably a good start.  When a connection comes in, we want to add it to our map of known clients.</p>
<p>If a connection drops off (i.e, returns <code>Poll::Ready(None)</code> from the <code>Stream</code>) then we can clean it from our known connections. If a new client with the same name comes in, we can just drop off the old client connection (alternatively, we could reject the new one).  These semantics are obviously different from the <a href="http://api.zeromq.org/4-3:zmq-socket#toc25">ZeroMQ Router socket</a>, and not nearly as robust, but are good enough for a PoC.</p>
<p>The router can be implemented as a <code>Stream</code> which, when polled will check:</p>
<ul>
<li>Any pending tcp connections</li>
<li>Any pending clients that are in the middle of handshaking</li>
<li>Any pending messages from existing clients</li>
</ul>
<p>This can be seen as a loop, whereby each time we hit <code>poll_next</code> we will hit all 3 areas in case we have anything waiting for us.  If there is nothing in one area, then we move onto the next one, and so on.  We can do an <code>if let Poll::Ready()</code> pattern here to skip things that aren't ready.</p>
<h4 id="pending-clients">Pending Clients</h4>
<p>How do we know the client name when connecting?  Well we can implement a list of pending clients.  When they send a <code>ServerMessage::Hello</code>  message, we can then put them in our known clients list.  This is a pretty lightweight handshake, but accomplishes our goals.</p>
<p>First, we convert the tcp stream from listener into a list of pending clients:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> self_mut </span><span style="color:#f29e74;">= &amp;</span><span style="color:#ffa759;">mut </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">as_mut</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">if let </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(val) </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Pin</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">listener)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx) {
    </span><span style="color:#ffa759;">match</span><span style="color:#ccc9c2;"> val {
        </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(tcp_stream)) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> length_delimited </span><span style="color:#f29e74;">=
                </span><span style="color:#ccc9c2;">CodecFramed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(tcp_stream</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">LengthDelimitedCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new())</span><span style="color:#ccc9c2cc;">;

            </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> framed </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Framed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(length_delimited</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">Cbor</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">default())</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">

            self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">pending_clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span style="color:#ccc9c2;">(framed)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
        </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Err</span><span style="color:#ccc9c2;">(err)) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="color:#f28779;">error!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Error checking for new requests:{:?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> err)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
        </span><span style="font-style:italic;color:#5ccfe6;">None </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="color:#ffa759;">return </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">None</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
    }
}
</span></pre>
<p>Now, with that checked off, we can then consult our pending clients.  Note here I am swapping out the pending clients <code>Vec</code> with an empty <code>Vec</code> to avoid doubly borrowing as mutable.  There may be an easier/more efficient way of doing this and would be interested in knowing what that may look like.</p>
<p>We will repopulate the list as we go through, so we won't lose any pending clients, but one or two may drop off if they are not doing the handshake correctly or they have already disconnected.  We'll also add the <code>Hello</code> message to our messages to send as a <code>Stream</code> response.  That's our <code>buffer</code> that we will be using.</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> new_pending </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">mem</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">swap(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">pending_clients</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> new_pending)</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">for mut</span><span style="color:#ccc9c2;"> pending </span><span style="color:#f29e74;">in</span><span style="color:#ccc9c2;"> new_pending</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_iter</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">if let </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(val) </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Pin</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> pending)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx) {
        </span><span style="color:#ffa759;">match</span><span style="color:#ccc9c2;"> val {
            </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(ServerMessage</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Hello(name))) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
                </span><span style="color:#f28779;">debug!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;New Client connection from `{}`&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> name)</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
                self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span style="color:#ccc9c2;">(ServerMessage</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Hello(name</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">clone</span><span style="color:#ccc9c2;">()))</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
                self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span style="color:#ccc9c2;">(name</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> pending)</span><span style="color:#ccc9c2cc;">;
            </span><span style="color:#ccc9c2;">}
            </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(msg)) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
                </span><span style="color:#f28779;">warn!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Received unknown message during handshake:{:?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> msg)</span><span style="color:#ccc9c2cc;">;
            </span><span style="color:#ccc9c2;">}
            </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Err</span><span style="color:#ccc9c2;">(err)) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
                </span><span style="color:#f28779;">error!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Error checking for new requests:{:?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> err)</span><span style="color:#ccc9c2cc;">;
            </span><span style="color:#ccc9c2;">}
            </span><span style="font-style:italic;color:#5ccfe6;">None </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    } </span><span style="color:#ffa759;">else </span><span style="color:#ccc9c2;">{
        self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">pending_clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span style="color:#ccc9c2;">(pending)</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ccc9c2;">}
}
</span></pre><h4 id="existing-clients">Existing Clients</h4>
<p>We'll do the same <em>trick</em> for the client <code>HashMap</code>: swap it out for an empty one as we're processing.</p>
<p>We'll put all received messages into an internal buffer, which we will use later to send the actual response from the stream.</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> new_clients </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">HashMap</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">mem</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">swap(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> new_clients)</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">for </span><span style="color:#ccc9c2;">(name</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> client) </span><span style="color:#f29e74;">in</span><span style="color:#ccc9c2;"> new_clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into_iter</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">match </span><span style="color:#ccc9c2;">Pin</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> client)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx) {
        Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(val))) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="color:#f28779;">trace!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Received message from `{}`: {:?}&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> name</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> val)</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
            self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">push</span><span style="color:#ccc9c2;">(val)</span><span style="color:#ccc9c2cc;">;</span><span style="color:#ccc9c2;">
            self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span style="color:#ccc9c2;">(name</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> client)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
        Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">None</span><span style="color:#ccc9c2;">) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="font-style:italic;color:#5c6773;">//Finished
            </span><span style="color:#f28779;">debug!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Client `{}` disconnecting&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> name)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
        Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Err</span><span style="color:#ccc9c2;">(err))) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            </span><span style="font-style:italic;color:#5c6773;">//Error
            </span><span style="color:#f28779;">error!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Error from `{}`: {} Removing connection.&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> name</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> err)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
        Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Pending </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{
            self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">insert</span><span style="color:#ccc9c2;">(name</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> client)</span><span style="color:#ccc9c2cc;">;
        </span><span style="color:#ccc9c2;">}
    }
}
</span></pre><h4 id="returning-messages">Returning Messages</h4>
<p>We've buffered up the returned messages into a <code>Vec</code> and we can return one.  But if there are more after popping we can let the waker know we may have more stuff to process:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(val) </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">pop</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">if</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">buffer</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">len</span><span style="color:#ccc9c2;">() </span><span style="color:#f29e74;">&gt; </span><span style="color:#ffcc66;">0 </span><span style="color:#ccc9c2;">{
        cx</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">waker</span><span style="color:#ccc9c2;">()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">wake_by_ref</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ccc9c2;">}
    </span><span style="color:#ffa759;">return </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(val)))</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ffa759;">return </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Pending</span><span style="color:#ccc9c2cc;">;
</span></pre><h3 id="sending-messages">Sending Messages</h3>
<p>Sending messages requires that you know the name of the client, but it is otherwise a simple wrapper:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">pub</span><span style="color:#ccc9c2;"> async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">send_message</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">, </span><span style="color:#ffcc66;">client</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">str</span><span style="color:#ccc9c2;">, </span><span style="color:#ffcc66;">msg</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> ClientMessage) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Result&lt;(), Error&gt; {
    </span><span style="color:#ffa759;">if let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(connection) </span><span style="color:#f29e74;">= </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">get_mut</span><span style="color:#ccc9c2;">(client) {
        connection</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">send</span><span style="color:#ccc9c2;">(msg)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ccc9c2;">} </span><span style="color:#ffa759;">else </span><span style="color:#ccc9c2;">{
        </span><span style="color:#ffa759;">return </span><span style="font-style:italic;color:#5ccfe6;">Err</span><span style="color:#ccc9c2;">(</span><span style="color:#f28779;">anyhow!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Client `{}` not connected!&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> client))</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ccc9c2;">}

    </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(())
}
</span></pre>
<p>We can even expose a way to check if any clients are connected of that name, and simply not bother sending a message in this case:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">is_connected</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">, </span><span style="color:#ffcc66;">client</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">str</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">bool </span><span style="color:#ccc9c2;">{
    </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">clients</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">contains_key</span><span style="color:#ccc9c2;">(client)
}
</span></pre><h3 id="changes-to-the-server">Changes to the Server</h3>
<p>The <code>Server</code> struct itself does not really change all that much.  Instead of using a <code>tmq::router</code> we'll use our new <code>Router</code>.  Although strictly not equivalent, for the purpose of the job queue, this is an OK analogue:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> router </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Router</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">job_address)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">while let </span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(server_msg) </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> router</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">next</span><span style="color:#ccc9c2;">()</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await {
    </span><span style="font-style:italic;color:#5c6773;">// existing server logic here
</span><span style="color:#ccc9c2;">}
</span></pre><h2 id="implementing-clients">Implementing Clients</h2>
<p>Not much has changed here as well.  We could get away with not using our own struct definition here at all and just set up a connection, but would be great if we had something we could plop in where the old <code>tmq::dealer</code> was used.</p>
<h3 id="dealer">Dealer</h3>
<p>We implement a <code>Dealer</code> struct which simply wraps a <code>tokio_serde::Framed</code>:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">type </span><span style="color:#73d0ff;">ClientFramed </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Framed&lt;
    CodecFramed&lt;TcpStream, LengthDelimitedCodec&gt;,
    ClientMessage,
    ServerMessage,
    Cbor&lt;ClientMessage, ServerMessage&gt;,
&gt;</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">Dealer </span><span style="color:#ccc9c2;">{
    connection</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> ClientFramed,
}

</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">Dealer </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">pub</span><span style="color:#ccc9c2;"> async </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">&lt;A</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> ToSocketAddrs&gt;(</span><span style="color:#ffcc66;">addr</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> A) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Result&lt;</span><span style="color:#ffa759;">Self</span><span style="color:#ccc9c2;">, Error&gt; {
        </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> tcp_stream </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">TcpStream</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">connect(addr)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">;

        </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> length_delimited </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">CodecFramed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(tcp_stream</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">LengthDelimitedCodec</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new())</span><span style="color:#ccc9c2cc;">;

        </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> connection </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Framed</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(length_delimited</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">Cbor</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">default())</span><span style="color:#ccc9c2cc;">;

        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span style="color:#ccc9c2;">(</span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{ connection })
    }
}
</span></pre>
<p>With the dealer, both receiving and sending marry up with <code>Stream</code> and <code>Sink</code> quite well, so we can implement that quite easily:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">impl </span><span style="color:#ccc9c2;">Stream </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Dealer </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Item </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Result&lt;ClientMessage, Error&gt;</span><span style="color:#ccc9c2cc;">;

    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">poll_next</span><span style="color:#ccc9c2;">(</span><span style="color:#ffa759;">mut </span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">: Pin&lt;</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut Self</span><span style="color:#ccc9c2;">&gt;, </span><span style="color:#ffcc66;">cx</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="color:#ccc9c2;">Context&lt;&#39;</span><span style="color:#f29e74;">_</span><span style="color:#ccc9c2;">&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Poll&lt;Option&lt;</span><span style="color:#ffa759;">Self</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Item&gt;&gt; {
        </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> self_mut </span><span style="color:#f29e74;">= &amp;</span><span style="color:#ffa759;">mut </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">as_mut</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;

        </span><span style="color:#ffa759;">match </span><span style="color:#ccc9c2;">Pin</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> self_mut</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">connection)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">poll_next</span><span style="color:#ccc9c2;">(cx) {
            Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(val)) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">Some</span><span style="color:#ccc9c2;">(val</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map_err</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">err</span><span style="color:#ccc9c2;">| err</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())))</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">None</span><span style="color:#ccc9c2;">) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Ready(</span><span style="font-style:italic;color:#5ccfe6;">None</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Pending </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">Poll</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Pending</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}
</span></pre><h3 id="worker-changes">Worker Changes</h3>
<p>The worker doesn't change much, we <a href="https://github.com/cetra3/jobq/blob/518c6c025a9e10477819fcc87acf8747383e9ba3/src/worker.rs#L19">call split</a> on the <code>Dealer</code> struct to get our two pipes, but otherwise treat it as per normal:</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">let </span><span style="color:#ccc9c2;">(</span><span style="color:#ffa759;">mut</span><span style="color:#ccc9c2;"> send_skt</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> recv) </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Dealer</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ccc9c2;">job_address)</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">await</span><span style="color:#f29e74;">?.</span><span style="color:#f28779;">split</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span></pre><h2 id="running-the-changes">Running the Changes</h2>
<p>Running the branch we should see a lot of the same chatter we saw from the <a href="../implementing-a-jobq/">previous version</a>:</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;"> 2020-05-13 11:13:02 DEBUG jobq::server &gt; New: Job { id: 5500, username: &quot;test_client&quot;, name: &quot;test&quot;, uuid: 95182793-7a08-4329-a9f1-4be0c1f1d041, params: Null, priority: Normal, status: Queued }
 2020-05-13 11:13:02 WARN  jobq::server &gt; Job failed: 5496, Reason: Simulating failure
 2020-05-13 11:13:02 WARN  jobq::server &gt; Job failed: 5484, Reason: Simulating failure
 2020-05-13 11:13:02 WARN  jobq::server &gt; Job failed: 5472, Reason: Simulating failure
 2020-05-13 11:13:03 WARN  jobq::server &gt; Job failed: 5460, Reason: Simulating failure
</span></pre><h2 id="conclusion">Conclusion</h2>
<p>Implementing a more barebones messaging system native in rust took not much time at all.  While this solution is not nearly as robust as using ZeroMQ, it does provide a more building blocks approach to messaging, reducing external dependencies.  I found the hardest portion was gluing everything together between the 3 main crates and getting the types right.  <em>Tokio-Serde</em> could use a bit more fleshing out and does seem quite embryonic still, but it is enough to get your hands dirty.</p>
<p>The initial design of the jobq made it easy to slot in another transport layer as well.  All the structs &amp; types were all ready and rolling to go, we just needed a couple of extra libraries to fill in the pieces.</p>


  </section>
    <script src="https://utteranc.es/client.js"
            repo="cetra3/cetra3.github.io"
            issue-term="pathname"
            theme="dark-blue"
            crossorigin="anonymous"
            async>
    </script>
</article>


    </div>
    <script async defer data-domain="cetra3.github.io" src="https://plausible.io/js/plausible.js"></script>
</body>

</html>