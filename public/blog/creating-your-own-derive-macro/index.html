<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creating your own custom derive macro</title>
    <meta name="description" content="Harnessing the power of `syn` and `quote` to create custom rust macros" />
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}body{margin:0}article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figcaption,figure,main{display:block}hr{box-sizing:content-box;height:0;overflow:visible;}a{background-color:rgba(0,0,0,0);-webkit-text-decoration-skip:objects;}a:active,a:hover{outline-width:0}address{font-style:normal}b,strong{font-weight:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:"SF Mono","Segoe UI Mono","Roboto Mono",Menlo,Courier,monospace;font-size:1em;}dfn{font-style:italic}small{font-size:80%;font-weight:400;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not(:root){overflow:hidden}button,input,optgroup,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit;margin:0;}button,input{overflow:visible}button,select{text-transform:none}button,html [type=button],[type=reset],[type=submit]{-webkit-appearance:button;}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}fieldset{border:0;margin:0;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{display:inline-block;vertical-align:baseline;}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0;}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px;}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details,menu{display:block}summary{display:list-item;outline:none}canvas{display:inline-block}template{display:none}[hidden]{display:none}*,*::before,*::after{box-sizing:inherit}html{box-sizing:border-box;font-size:20px;line-height:1.5;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{background:#303742;color:#fff;font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",sans-serif;font-size:.8rem;overflow-x:hidden;text-rendering:optimizeLegibility}a{color:#73c6ec;outline:none;text-decoration:none}a:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}a:focus,a:hover,a:active,a.active{color:#46b4e6;text-decoration:underline}a:visited{color:#a0d8f2}h1,h2,h3,h4,h5,h6{color:inherit;font-weight:700;line-height:1.2;margin-bottom:.5rem;margin-top:0}.h1,.h2,.h3,.h4,.h5,.h6{font-weight:700}h1,.h1{font-size:2rem}h2,.h2{font-size:1.6rem}h3,.h3{font-size:1.4rem}h4,.h4{font-size:1.2rem}h5,.h5{font-size:1rem}h6,.h6{font-size:.8rem}p{margin:0 0 1.2rem}a,ins,u{text-decoration-skip:ink edges}abbr[title]{border-bottom:.05rem dotted;cursor:help;text-decoration:none}kbd{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#303742;color:#fff;font-size:.7rem}mark{background:#ffe9b3;color:#fff;border-bottom:.05rem solid #ffd367;border-radius:.1rem;padding:.05rem .1rem 0}blockquote{border-left:.1rem solid #dadee4;margin-left:0;padding:.4rem .8rem}blockquote p:last-child{margin-bottom:0}ul,ol{margin:.8rem 0 .8rem .8rem;padding:0}ul ul,ul ol,ol ul,ol ol{margin:.8rem 0 .8rem .8rem}ul li,ol li{margin-top:.4rem}ul{list-style:disc inside}ul ul{list-style-type:circle}ol{list-style:decimal inside}ol ol{list-style-type:lower-alpha}dl dt{font-weight:bold}dl dd{margin:.4rem 0 .8rem 0}.btn{appearance:none;background:#fff;border:.05rem solid #73c6ec;border-radius:.1rem;color:#73c6ec;cursor:pointer;display:inline-block;font-size:.8rem;height:2.5rem;line-height:1.2rem;outline:none;padding:.6rem .4rem;text-align:center;text-decoration:none;transition:background .2s,border .2s,box-shadow .2s,color .2s;user-select:none;vertical-align:middle;white-space:nowrap}.btn:focus{box-shadow:0 0 0 .1rem rgba(115,198,236,.2)}.btn:focus,.btn:hover{background:#fff;border-color:#66c1ea;text-decoration:none}.btn:active,.btn.active{background:#66c1ea;border-color:#4fb7e7;color:#fff;text-decoration:none}.btn:active.loading::after,.btn.active.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn[disabled],.btn:disabled,.btn.disabled{cursor:default;opacity:.5;pointer-events:none}.btn.btn-primary{background:#73c6ec;border-color:#66c1ea;color:#fff}.btn.btn-primary:focus,.btn.btn-primary:hover{background:#5dbde9;border-color:#4fb7e7;color:#fff}.btn.btn-primary:active,.btn.btn-primary.active{background:#54b9e8;border-color:#46b4e6;color:#fff}.btn.btn-primary.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-success{background:#32b643;border-color:#2faa3f;color:#fff}.btn.btn-success:focus{box-shadow:0 0 0 .1rem rgba(50,182,67,.2)}.btn.btn-success:focus,.btn.btn-success:hover{background:#30ae40;border-color:#2da23c;color:#fff}.btn.btn-success:active,.btn.btn-success.active{background:#2a9a39;border-color:#278e34;color:#fff}.btn.btn-success.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-error{background:#e85600;border-color:#d95000;color:#fff}.btn.btn-error:focus{box-shadow:0 0 0 .1rem rgba(232,86,0,.2)}.btn.btn-error:focus,.btn.btn-error:hover{background:#de5200;border-color:#cf4d00;color:#fff}.btn.btn-error:active,.btn.btn-error.active{background:#c44900;border-color:#b54300;color:#fff}.btn.btn-error.loading::after{border-bottom-color:#fff;border-left-color:#fff}.btn.btn-link{background:rgba(0,0,0,0);border-color:rgba(0,0,0,0);color:#73c6ec}.btn.btn-link:focus,.btn.btn-link:hover,.btn.btn-link:active,.btn.btn-link.active{color:#46b4e6}.btn.btn-sm{font-size:.7rem;height:1.4rem;padding:.05rem .3rem}.btn.btn-lg{font-size:.9rem;height:2rem;padding:.35rem .6rem}.btn.btn-block{display:block;width:100%}.btn.btn-action{width:2.5rem;padding-left:0;padding-right:0}.btn.btn-action.btn-sm{width:1.4rem}.btn.btn-action.btn-lg{width:2rem}.btn.btn-clear{background:rgba(0,0,0,0);border:0;color:currentColor;height:1rem;line-height:.8rem;margin-left:.2rem;margin-right:-2px;opacity:1;padding:.1rem;text-decoration:none;width:1rem}.btn.btn-clear:focus,.btn.btn-clear:hover{background:rgba(48,55,66,.5);opacity:.95}.btn.btn-clear::before{content:"âœ•"}.btn-group{display:inline-flex;flex-wrap:wrap}.btn-group .btn{flex:1 0 auto}.btn-group .btn:first-child:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group .btn:not(:first-child):not(:last-child){border-radius:0;margin-left:-.05rem}.btn-group .btn:last-child:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-.05rem}.btn-group .btn:focus,.btn-group .btn:hover,.btn-group .btn:active,.btn-group .btn.active{z-index:1}.btn-group.btn-group-block{display:flex}.btn-group.btn-group-block .btn{flex:1 0 0}.label{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#39414e;color:#e6e6e6;display:inline-block}.label.label-rounded{border-radius:5rem;padding-left:.4rem;padding-right:.4rem}.label.label-primary{background:#0b3e55;color:#fff}.label.label-secondary{background:#fff;color:#73c6ec}.label.label-success{background:#32b643;color:#fff}.label.label-warning{background:#ffb700;color:#fff}.label.label-error{background:#e85600;color:#fff}p code{border-radius:.1rem;line-height:1.2;padding:.1rem .2rem;background:#0f4e6b;color:#fff;font-size:85%}.code{border-radius:.1rem;color:#fff;position:relative}.code::before{color:#bcc3ce;content:attr(data-lang);font-size:.7rem;position:absolute;right:.4rem;top:.1rem}.code code{background:#303742;color:inherit;display:block;line-height:1.5;overflow-x:auto;padding:1rem;width:100%}.container{margin-left:auto;margin-right:auto;padding-left:.4rem;padding-right:.4rem;width:100%}.container.grid-xl{max-width:1296px}.container.grid-lg{max-width:976px}.container.grid-md{max-width:856px}.container.grid-sm{max-width:616px}.container.grid-xs{max-width:496px}.show-xs,.show-sm,.show-md,.show-lg,.show-xl{display:none !important}.columns{display:flex;flex-wrap:wrap;margin-left:-.4rem;margin-right:-.4rem}.columns.col-gapless{margin-left:0;margin-right:0}.columns.col-gapless>.column{padding-left:0;padding-right:0}.columns.col-oneline{flex-wrap:nowrap;overflow-x:auto}.column{flex:1;max-width:100%;padding-left:.4rem;padding-right:.4rem}.column.col-12,.column.col-11,.column.col-10,.column.col-9,.column.col-8,.column.col-7,.column.col-6,.column.col-5,.column.col-4,.column.col-3,.column.col-2,.column.col-1{flex:none}.col-12{width:100%}.col-11{width:91.66666667%}.col-10{width:83.33333333%}.col-9{width:75%}.col-8{width:66.66666667%}.col-7{width:58.33333333%}.col-6{width:50%}.col-5{width:41.66666667%}.col-4{width:33.33333333%}.col-3{width:25%}.col-2{width:16.66666667%}.col-1{width:8.33333333%}.col-auto{flex:0 0 auto;max-width:none;width:auto}.col-mx-auto{margin-left:auto;margin-right:auto}.col-ml-auto{margin-left:auto}.col-mr-auto{margin-right:auto}@media (max-width: 1280px){.col-xl-12,.col-xl-11,.col-xl-10,.col-xl-9,.col-xl-8,.col-xl-7,.col-xl-6,.col-xl-5,.col-xl-4,.col-xl-3,.col-xl-2,.col-xl-1{flex:none}.col-xl-12{width:100%}.col-xl-11{width:91.66666667%}.col-xl-10{width:83.33333333%}.col-xl-9{width:75%}.col-xl-8{width:66.66666667%}.col-xl-7{width:58.33333333%}.col-xl-6{width:50%}.col-xl-5{width:41.66666667%}.col-xl-4{width:33.33333333%}.col-xl-3{width:25%}.col-xl-2{width:16.66666667%}.col-xl-1{width:8.33333333%}.hide-xl{display:none !important}.show-xl{display:block !important}}@media (max-width: 960px){.col-lg-12,.col-lg-11,.col-lg-10,.col-lg-9,.col-lg-8,.col-lg-7,.col-lg-6,.col-lg-5,.col-lg-4,.col-lg-3,.col-lg-2,.col-lg-1{flex:none}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.hide-lg{display:none !important}.show-lg{display:block !important}}@media (max-width: 840px){.col-md-12,.col-md-11,.col-md-10,.col-md-9,.col-md-8,.col-md-7,.col-md-6,.col-md-5,.col-md-4,.col-md-3,.col-md-2,.col-md-1{flex:none}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.hide-md{display:none !important}.show-md{display:block !important}}@media (max-width: 600px){.col-sm-12,.col-sm-11,.col-sm-10,.col-sm-9,.col-sm-8,.col-sm-7,.col-sm-6,.col-sm-5,.col-sm-4,.col-sm-3,.col-sm-2,.col-sm-1{flex:none}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.hide-sm{display:none !important}.show-sm{display:block !important}}@media (max-width: 480px){.col-xs-12,.col-xs-11,.col-xs-10,.col-xs-9,.col-xs-8,.col-xs-7,.col-xs-6,.col-xs-5,.col-xs-4,.col-xs-3,.col-xs-2,.col-xs-1{flex:none}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.hide-xs{display:none !important}.show-xs{display:block !important}}.navbar{align-items:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin-left:auto;margin-right:auto;max-width:960px}.navbar .navbar-section{align-items:center;display:flex;flex:1 0 0}.navbar .navbar-section:not(:first-child):last-child{justify-content:flex-end}.navbar .navbar-center{align-items:center;display:flex;flex:0 0 auto}.navbar .navbar-brand{font-size:.9rem;text-decoration:none}pre{padding:.5rem .5rem;border-radius:.3rem;overflow-y:auto}.post header{border-radius:.3rem;padding:.5rem;margin-bottom:.5rem}.post header h1{margin-bottom:0}.post section{padding:.5rem;background-color:#2a3039;border-radius:.3rem}.post img{width:100%}.post .utterances{max-width:none !important}.card{margin-bottom:.5rem}.main-header{margin-bottom:.5rem;background-color:#272d36;box-shadow:0 20rem 20rem 20rem rgba(115,198,236,.2)}.card{background:#2a3039;border-radius:.3rem;display:flex;flex-direction:column}.card .card-header,.card .card-body,.card .card-footer{padding:.8rem;padding-bottom:0}.card .card-header:last-child,.card .card-body:last-child,.card .card-footer:last-child{padding-bottom:.8rem}.card .card-body{flex:1 1 auto}.card .card-image{padding-top:.8rem}.card .card-image:first-child{padding-top:0}.card .card-image:first-child img{border-top-left-radius:.1rem;border-top-right-radius:.1rem}.card .card-image:last-child img{border-bottom-left-radius:.1rem;border-bottom-right-radius:.1rem}</style>
</head>

<body>
    <header class="main-header">
        <div class="navbar">
        <section class="navbar-section">
            <img src="/favicon.svg" width="30" height="30"/>
            <a href="/" class="btn btn-link">Home</a>
            <a href="/blog/" class="btn btn-link">Blogs</a>
            <a href="/rss.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-center">
        </section>
        <section class="navbar-section">
            <a href="https://github.com/cetra3/" class="btn btn-link">GitHub</a>
            <a href="https://twitter.com/cetra3" class="btn btn-link">Twitter</a>
            <a href="https://mastodon.social/@cetra3" class="btn btn-link">Mastodon</a>
        </section>
        </div>
    </header>
    <div class="container grid-lg">
        
<article class="post">
  <header>
  <h1>Creating your own custom derive macro </h1>
  <em>Harnessing the power of `syn` and `quote` to create custom rust macros</em>
  <br />
  
  <small class="label label-primary">rust</small> <small class="label label-primary">divedb</small> <small class="label">2023-07-23</small>
  
  </header>
  <section>
    <p>One of the things I tackled early on with when creating <a href="https://github.com/cetra3/divedb">DiveDB</a> was trying to import a lot of metrics from dive logs. At regular intervals, normally every 10 seconds, a dive computer will record metrics about the dive, such as depth, tank pressure, water temperature etc... While this isn't a <em>huge</em> amount of entries, nearly every SQL framework I used for it was painfully slow at importing this type of data.</p>
<p>The only crate that I managed to get to work with reasonable performance was <a href="https://docs.rs/tokio-postgres/latest/tokio_postgres/">tokio-postgres</a>.  Itself being lightweight: it doesn't include a lot of features you would expect from a full blown SQL framework like <a href="http://diesel.rs/">diesel</a> or <a href="https://github.com/launchbadge/sqlx">SQLx</a>. I was OK with that, I don't mind writing a bit of raw SQL, but one thing I thought was missing was some sort of way to create a struct from a database row.</p>
<p>So I set out to make a really simple trait to hydrate a struct from a row. The obvious candidate for this is a procedural macro. Writing procedural macros has been written about before, but I haven't found a terse enough guide that I was happy with. I wanted to document my approach in the odd chance it helps other people.  At the very least I have something to refer to if I need to do this again!</p>
<h2 id="aim-of-the-macro">Aim of the Macro</h2>
<p>The Aim of the macro is to be able to write <code>#[derive(MyTrait)]</code> and have it fill in the trait implementation at compile time.</p>
<p>In this case I will be deriving a simple trait that looks like this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>anyhow</span><span style="color:#f29e74;">::</span><span>Error</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">pub trait </span><span style="color:#73d0ff;">FromRow </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">/// hydrate a struct from a database `Row`
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">:</span><span> Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        </span><span style="color:#ffa759;">Self</span><span style="color:#ccc9c2cc;">: </span><span>std</span><span style="color:#f29e74;">::</span><span>marker</span><span style="color:#f29e74;">::</span><span>Sized;
</span><span>
</span><span>}
</span></code></pre>
<p>There are a few things I have made the decision not to handle to keep things simple:</p>
<ul>
<li>SQLx is already has some great macros for validating against a live schema. I don't want to reimplement this here.</li>
<li>I don't want to pay the cost of column index lookups for named fields. Instead, we will use indices and expect the queries we write return fields in correct order.</li>
</ul>
<p>So if I have a struct like this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">DiveMetric </span><span>{
</span><span>    </span><span style="color:#ffa759;">pub </span><span>time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">i32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>depth</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>pressure</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>temperature</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>It should automatically derive the trait like so:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span>FromRow </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">DiveMetric </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">:</span><span> Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, Error&gt; {
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>            time</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">0</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            depth</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">1</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            pressure</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">2</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            temperature</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">3</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="crate-layout">Crate Layout</h2>
<p>You will need at minimum 2 crates to do this:</p>
<ul>
<li>One crate for the macro itself.  I.e, it has <code>proc-macro = true</code> in the Manifest, I called this <code>macro</code></li>
<li>One crate has the definitions of the trait. I have called this <code>core</code>.  This crate will include the macro as a dependency</li>
<li>Any extra crates that require this can depend on <code>core</code></li>
</ul>
<h2 id="procedural-macro-crate">Procedural Macro Crate</h2>
<p>A Procedural Macro Crate is built at compile time and can influence your source code, pretty much by injecting source code in the form of &quot;tokens&quot; in-line with the rest of your code. </p>
<p>The <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> interface is very very bare minimum.  You get a list of these tokens and it's up to you to work out what they mean.  Luckily there is a crate out there, <a href="https://github.com/dtolnay/syn"><code>syn</code></a>, for parsing a <code>TokenStream</code> into a higher level structure.  Think reflection but at compile time.</p>
<p>So firstly, let's set up the crate manifest:</p>
<pre data-lang="toml" style="background-color:#212733;color:#ccc9c2;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#73d0ff;">package</span><span>]
</span><span style="color:#73d0ff;">name </span><span>= </span><span style="color:#bae67e;">&quot;divedb_macro&quot;
</span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;0.1.0&quot;
</span><span style="color:#73d0ff;">edition </span><span>= </span><span style="color:#bae67e;">&quot;2021&quot;
</span><span>
</span><span>[</span><span style="color:#73d0ff;">lib</span><span>]
</span><span style="color:#73d0ff;">proc-macro </span><span>= </span><span style="color:#ffcc66;">true
</span><span>
</span><span>[</span><span style="color:#73d0ff;">dependencies</span><span>]
</span><span style="color:#73d0ff;">syn </span><span>= { </span><span style="color:#73d0ff;">version </span><span>= </span><span style="color:#bae67e;">&quot;2&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#73d0ff;">features </span><span>= [</span><span style="color:#bae67e;">&quot;full&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#bae67e;">&quot;parsing&quot;</span><span>] }
</span></code></pre>
<p>This is a standard crate, with the only difference is in that <code>lib</code> section: we tell it this is a proc-macro crate.</p>
<p>Then, we are going to create a derive macro with the same name as the trait, i.e, <code>FromRow</code>.  We will just create this in <code>lib.rs</code> the entrypoint to our crate.</p>
<p>The scaffolding we have to lay out is a method that looks something like this:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>proc_macro</span><span style="color:#f29e74;">::</span><span>TokenStream</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">proc_macro_derive</span><span>(FromRow)]
</span><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">derive_from_row</span><span>(</span><span style="color:#ffcc66;">input</span><span style="color:#ccc9c2cc;">:</span><span> TokenStream) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> TokenStream {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// do something with the token stream here
</span><span>}
</span></code></pre>
<h3 id="parsing-the-tokenstream">Parsing the TokenStream</h3>
<p>First step is to convert a <code>TokenStream</code> into a structure we can work with.  We'll use <code>syn</code> to do the heavy lifting here.  There are some helper methods to parse out as a <a href="https://docs.rs/syn/latest/syn/struct.DeriveInput.html"><code>DeriveInput</code></a> struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> input </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">parse_macro_input!</span><span>(input </span><span style="color:#f29e74;">as</span><span> DeriveInput)</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Looking at <code>DeriveInput</code>, there is the <a href="https://docs.rs/syn/latest/syn/enum.Data.html"><code>Data</code></a> enum, which is an enum of 3 different types, <code>Struct</code>, <code>Enum</code> or <code>Union</code>. </p>
<p>We only care about structs, and don't want to derive it for anything else.</p>
<p>So what we can do is an <code>if let</code> match on the variant we want, and otherwise error out with some sort of message that will hopefully remind you when you derive it later on.  There are a few ways to error out &amp; most require a <code>span</code>: the portion of the <code>TokenStream</code> that relates to the error.  I.e, where the red squiggly line will show up. You can also <code>panic!</code> if you are shortcutting massively, but I wouldn't recommend it.</p>
<p>I've elected to do a catchall in the case it's not in a structure that I want to support. </p>
<p>Using <a href="https://docs.rs/syn/latest/syn/struct.Error.html"><code>syn::Error</code></a>, we can provide it a span, and a message.</p>
<p>Since our method needs to return a <code>TokenStream</code>, not a <code>syn::Error</code>, we can convert the error by injecting a <code>compile_error!()</code> in the form of a <code>TokenStream</code> by using the <a href="https://docs.rs/syn/latest/syn/struct.Error.html#method.to_compile_error"><code>to_compile_error()</code></a> function:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">proc_macro_derive</span><span>(FromRow)]
</span><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">derive_from_row</span><span>(</span><span style="color:#ffcc66;">input</span><span style="color:#ccc9c2cc;">:</span><span> TokenStream) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> TokenStream {
</span><span>    </span><span style="color:#ffa759;">let</span><span> input </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">parse_macro_input!</span><span>(input </span><span style="color:#f29e74;">as</span><span> DeriveInput)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Do something with the fields here
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Catchall if we don&#39;t match on the structure we don&#39;t want
</span><span>    TokenStream</span><span style="color:#f29e74;">::</span><span>from(
</span><span>        syn</span><span style="color:#f29e74;">::</span><span>Error</span><span style="color:#f29e74;">::</span><span>new(
</span><span>            input</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">span</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>            </span><span style="color:#bae67e;">&quot;Only structs with named fields can derive `FromRow`&quot;
</span><span>        )</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_compile_error</span><span>()
</span><span>    )
</span><span>}
</span></code></pre>
<p>A lot of the examples for proc macros I've seen introduce more methods and structure here, but for brevity I've kept it all in the one method.</p>
<p>With our high level structure out of the way, we can do an <code>if let</code> match on finding a struct:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">if let </span><span>syn</span><span style="color:#f29e74;">::</span><span>Data</span><span style="color:#f29e74;">::</span><span>Struct(</span><span style="color:#ffa759;">ref</span><span> data) </span><span style="color:#f29e74;">=</span><span> input</span><span style="color:#f29e74;">.</span><span>data {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// we know it&#39;s a struct
</span><span>
</span><span>}
</span></code></pre>
<p>You'll find that there are actually 3 variants of a struct: Named field structs, Unnamed (tuple) structs and unit structs:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Named </span><span>{
</span><span>    field</span><span style="color:#ccc9c2cc;">:</span><span> String
</span><span>}
</span><span>
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Unnamed</span><span>(String)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Unit</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>It might be important if you are fleshing out a derive macro to deal with those other two cases. For this macro we only care about the first variant, the name field struct, not the other two. So we match on that:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">if let </span><span>Fields</span><span style="color:#f29e74;">::</span><span>Named(</span><span style="color:#ffa759;">ref</span><span> fields) </span><span style="color:#f29e74;">=</span><span> data</span><span style="color:#f29e74;">.</span><span>fields {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Deal with a named-field struct
</span><span>
</span><span>}
</span></code></pre>
<h3 id="emitting-our-tokenstream">Emitting our TokenStream</h3>
<p>From here, we want to iterate over the fields, and for each field emit a bit of code like:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f29e74;">&lt;</span><span>field_name</span><span style="color:#f29e74;">&gt;</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#f29e74;">&lt;</span><span>field_idx</span><span style="color:#f29e74;">&gt;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span></code></pre>
<p>However: we can't just send a <code>String</code> back from our method, we need to provide a <code>TokenStream</code>.  This is where the second handy crate comes in: <a href="https://github.com/dtolnay/quote"><code>quote</code></a>. We can use the <code>quote!</code> macro to generate code snippets in a mostly-readable fashion and output them as a <code>TokenStream</code>.  One thing to note: <code>quote!</code> will return a <code>proc_macro2</code> <code>TokenStream</code>, so you can either call <code>into()</code> or use <code>TokenStream::from</code>.</p>
<p>So let's iterate over our fields, and for each field, return a snippet, a <code>TokenStream</code>, which we can combine later:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> field_vals </span><span style="color:#f29e74;">=</span><span> fields</span><span style="color:#f29e74;">.</span><span>named</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">iter</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">enumerate</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|(</span><span style="color:#ffcc66;">i</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">field</span><span>)| {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// grab the name of the field
</span><span>    </span><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">= &amp;</span><span>field</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#f28779;">quote!</span><span>(</span><span style="color:#f29e74;">#</span><span>name</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#f29e74;">#</span><span>i)</span><span style="color:#f29e74;">?</span><span>)
</span><span>})</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>We're using the standard <code>iter().enumerate()</code> here to get out an index number of the field and the <code>field.ident</code> to reflect the name of the field.</p>
<p>As an alternative, if instead you wanted to use column names instead of column indices, you could adjust this easily:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> field_vals </span><span style="color:#f29e74;">=</span><span> fields</span><span style="color:#f29e74;">.</span><span>named</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">iter</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|</span><span style="color:#ffcc66;">field</span><span>| {
</span><span>    </span><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">=</span><span> field</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">as_ref</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#ffa759;">let</span><span> name_string </span><span style="color:#f29e74;">=</span><span> name</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_string</span><span>()</span><span style="color:#ccc9c2cc;">;
</span><span>    </span><span style="color:#f28779;">quote!</span><span>(</span><span style="color:#f29e74;">#</span><span>name</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#f29e74;">#</span><span>name_string)</span><span style="color:#f29e74;">?</span><span>)
</span><span>})</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>Ok, now we have a list of fields, and for each field, we have a snippet of source code, the next is to combine them and implement the <code>FromRow</code> trait.  Once again we can use <code>quote!</code> to do this.</p>
<p>Another thing worth noting is that it's as if the proc macro literally injects a bit of source code in-line where you call derive. This means that if you are going to refer to any structs/crates/modules etc.. it makes things a lot easier to refer to them via their full path.  I.e, don't put <code>Row</code>, put <code>::tokio_postgres::Row</code> instead.</p>
<p>With that in mind, here's our simple <code>quote!</code> statement:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">=</span><span> input</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#f28779;">quote!</span><span>(
</span><span style="color:#ffa759;">impl </span><span style="color:#f29e74;">::</span><span>divedb_core</span><span style="color:#f29e74;">::</span><span>FromRow </span><span style="color:#ffa759;">for</span><span> #</span><span style="color:#73d0ff;">name </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">: </span><span style="color:#f29e74;">::</span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, </span><span style="color:#f29e74;">::</span><span>anyhow</span><span style="color:#f29e74;">::</span><span>Error&gt; {
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>            </span><span style="color:#f29e74;">#</span><span>(</span><span style="color:#f29e74;">#</span><span>field_vals)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#f29e74;">*
</span><span>        })
</span><span>    }
</span><span>})
</span></code></pre>
<p>Most of this is self-explanatory.  The only weird/interesting thing is this part:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f29e74;">#</span><span>(</span><span style="color:#f29e74;">#</span><span>field_vals)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#f29e74;">*
</span></code></pre>
<p>This will just iterate over our field vals, and include each one.</p>
<p>Putting it all together, we get a pretty terse, but powerful proc macro:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>proc_macro</span><span style="color:#f29e74;">::</span><span>TokenStream</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>quote</span><span style="color:#f29e74;">::</span><span>quote</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>syn</span><span style="color:#f29e74;">::</span><span>{parse_macro_input</span><span style="color:#ccc9c2cc;">,</span><span> DeriveInput</span><span style="color:#ccc9c2cc;">,</span><span> Fields}</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">/// This derives the `FromRow` trait for structs
</span><span style="font-style:italic;color:#5c6773;">/// Requires that the query is in field order, as it just uses row indices
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">proc_macro_derive</span><span>(FromRow)]
</span><span style="color:#ffa759;">pub fn </span><span style="color:#ffd580;">derive_from_row</span><span>(</span><span style="color:#ffcc66;">input</span><span style="color:#ccc9c2cc;">:</span><span> TokenStream) </span><span style="color:#ccc9c2cc;">-&gt;</span><span> TokenStream {
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Parse it as a proc macro
</span><span>    </span><span style="color:#ffa759;">let</span><span> input </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">parse_macro_input!</span><span>(input </span><span style="color:#f29e74;">as</span><span> DeriveInput)</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>    </span><span style="color:#ffa759;">if let </span><span>syn</span><span style="color:#f29e74;">::</span><span>Data</span><span style="color:#f29e74;">::</span><span>Struct(</span><span style="color:#ffa759;">ref</span><span> data) </span><span style="color:#f29e74;">=</span><span> input</span><span style="color:#f29e74;">.</span><span>data {
</span><span>        </span><span style="color:#ffa759;">if let </span><span>Fields</span><span style="color:#f29e74;">::</span><span>Named(</span><span style="color:#ffa759;">ref</span><span> fields) </span><span style="color:#f29e74;">=</span><span> data</span><span style="color:#f29e74;">.</span><span>fields {
</span><span>            </span><span style="color:#ffa759;">let</span><span> field_vals </span><span style="color:#f29e74;">=</span><span> fields</span><span style="color:#f29e74;">.</span><span>named</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">iter</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">enumerate</span><span>()</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span>(|(</span><span style="color:#ffcc66;">i</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">field</span><span>)| {
</span><span>                </span><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">= &amp;</span><span>field</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#ccc9c2cc;">;
</span><span>                </span><span style="color:#f28779;">quote!</span><span>(</span><span style="color:#f29e74;">#</span><span>name</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#f29e74;">#</span><span>i)</span><span style="color:#f29e74;">?</span><span>)
</span><span>            })</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>            </span><span style="color:#ffa759;">let</span><span> name </span><span style="color:#f29e74;">=</span><span> input</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span>            </span><span style="color:#ffa759;">return </span><span>TokenStream</span><span style="color:#f29e74;">::</span><span>from(</span><span style="color:#f28779;">quote!</span><span>(
</span><span>            </span><span style="color:#ffa759;">impl </span><span>divedb_core</span><span style="color:#f29e74;">::</span><span>FromRow </span><span style="color:#ffa759;">for</span><span> #</span><span style="color:#73d0ff;">name </span><span>{
</span><span>                </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">: </span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, anyhow</span><span style="color:#f29e74;">::</span><span>Error&gt; {
</span><span>                    </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>                        </span><span style="color:#f29e74;">#</span><span>(</span><span style="color:#f29e74;">#</span><span>field_vals)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#f29e74;">*
</span><span>                    })
</span><span>                }
</span><span>            }))</span><span style="color:#ccc9c2cc;">;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    TokenStream</span><span style="color:#f29e74;">::</span><span>from(
</span><span>        syn</span><span style="color:#f29e74;">::</span><span>Error</span><span style="color:#f29e74;">::</span><span>new(
</span><span>            input</span><span style="color:#f29e74;">.</span><span>ident</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">span</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>            </span><span style="color:#bae67e;">&quot;Only structs with named fields can derive `FromRow`&quot;</span><span style="color:#ccc9c2cc;">,
</span><span>        )
</span><span>        </span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_compile_error</span><span>()</span><span style="color:#ccc9c2cc;">,
</span><span>    )
</span><span>}
</span></code></pre>
<h2 id="core-crate">Core Crate</h2>
<p>The core crate implements the trait itself &amp; also exports the macro as well.  If the macro &amp; trait are the same name, you can cheat and <code>pub use</code> the macro crate so you don't always have to import the macro &amp; trait separately.</p>
<p>Otherwise the core <code>lib.rs</code> is rather simple:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>anyhow</span><span style="color:#f29e74;">::</span><span>Error</span><span style="color:#ccc9c2cc;">;
</span><span style="font-style:italic;color:#5c6773;">// Export our derive macro here.
</span><span style="color:#ffa759;">pub use </span><span>divedb_macro</span><span style="color:#f29e74;">::*</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">use </span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="font-style:italic;color:#5c6773;">/// Really simple ORM for `tokio_postgres`
</span><span style="color:#ffa759;">pub trait </span><span style="color:#73d0ff;">FromRow </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">/// hydrate a struct from a database `Row`
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">:</span><span> Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, Error&gt;
</span><span>    </span><span style="color:#ffa759;">where
</span><span>        </span><span style="color:#ffa759;">Self</span><span style="color:#ccc9c2cc;">: </span><span>std</span><span style="color:#f29e74;">::</span><span>marker</span><span style="color:#f29e74;">::</span><span>Sized;
</span><span>
</span><span>    ...
</span><span>}
</span></code></pre>
<h2 id="standard-crate">Standard Crate</h2>
<p>Now we have the macro crate, the core crate, we can simply <code>use</code> this to derive on our own types:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">use </span><span>divedb_core</span><span style="color:#f29e74;">::</span><span>FromRow</span><span style="color:#ccc9c2cc;">;
</span><span>
</span><span style="color:#ccc9c2cc;">#</span><span>[</span><span style="color:#ffd580;">derive</span><span>(FromRow)]
</span><span style="color:#ffa759;">pub struct </span><span style="color:#73d0ff;">DiveMetric </span><span>{
</span><span>    </span><span style="color:#ffa759;">pub </span><span>time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">i32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>depth</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">f32</span><span>,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>pressure</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#ffa759;">pub </span><span>temperature</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Option</span><span>&lt;</span><span style="color:#ffa759;">f32</span><span>&gt;,
</span><span>}
</span></code></pre>
<h3 id="expanding-the-macro">Expanding the Macro</h3>
<p>Remember when I said that these macros pretty much inject more source code in line?  Well you can see that intermediate output rather easily by using <a href="https://github.com/dtolnay/cargo-expand"><code>cargo expand</code></a>.  This will print out the results of the macro expansion and show what code is actually being generated &amp; a <em>lot</em> more.  If you are writing something super tricky, it really helps to see this output &amp; makes a great tool for debugging procedural macros.</p>
<p>I.e, for our above <code>DiveMetric</code> struct, using column indices:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span>divedb_core</span><span style="color:#f29e74;">::</span><span>FromRow </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">DiveMetric </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">: </span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, anyhow</span><span style="color:#f29e74;">::</span><span>Error&gt; {
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>            time</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">0</span><span style="color:#ffa759;">usize</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            depth</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">1</span><span style="color:#ffa759;">usize</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            pressure</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">2</span><span style="color:#ffa759;">usize</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            temperature</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#ffcc66;">3</span><span style="color:#ffa759;">usize</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<p>And for using the column name variant:</p>
<pre data-lang="rust" style="background-color:#212733;color:#ccc9c2;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span>divedb_core</span><span style="color:#f29e74;">::</span><span>FromRow </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">DiveMetric </span><span>{
</span><span>    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from_row</span><span>(</span><span style="color:#ffcc66;">row</span><span style="color:#ccc9c2cc;">: </span><span>tokio_postgres</span><span style="color:#f29e74;">::</span><span>Row) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="font-style:italic;color:#5ccfe6;">Result</span><span>&lt;</span><span style="color:#ffa759;">Self</span><span>, anyhow</span><span style="color:#f29e74;">::</span><span>Error&gt; {
</span><span>        </span><span style="font-style:italic;color:#5ccfe6;">Ok</span><span>(</span><span style="color:#ffa759;">Self </span><span>{
</span><span>            time</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#bae67e;">&quot;time&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            depth</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#bae67e;">&quot;depth&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            pressure</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#bae67e;">&quot;pressure&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>            temperature</span><span style="color:#ccc9c2cc;">:</span><span> row</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">try_get</span><span>(</span><span style="color:#bae67e;">&quot;temperature&quot;</span><span>)</span><span style="color:#f29e74;">?</span><span style="color:#ccc9c2cc;">,
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>As you see, it's not <em>too</em> onerous to make your own custom derives.  There is a bit of boilerplate that is needed, but you can write code to write code and keep things simple.</p>
<p>Without greater support for compile time reflection in rust, you can reach for macros to help you remove the repetitive tasks we face as programmers</p>

  </section>
</article>


    </div>
</body>

</html>